<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sales Mood AI - Advanced Sales Intelligence Platform</title>
  <meta name="description" content="AI-powered sales coaching platform with real-time emotion analysis, performance analytics, and intelligent insights for sales professionals." />
  <meta name="keywords" content="sales AI, emotion analysis, sales coaching, performance analytics, sales intelligence" />
  <meta name="author" content="Sales Mood AI" />
  
  <!-- Professional SEO -->
  <meta property="og:title" content="Sales Mood AI - Advanced Sales Intelligence" />
  <meta property="og:description" content="Revolutionary AI platform for sales professionals with real-time coaching and analytics." />
  <meta property="og:type" content="website" />
  
  <!-- Favicon -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🧠</text></svg>" />
  <style>
    :root { --bg:#0b1220; --card:#121a2b; --text:#e8eefc; --muted:#94a3b8; --success:#22c55e; --warning:#f59e0b; --danger:#ef4444; }
    *{box-sizing:border-box} 
    body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    header{padding:16px 20px;border-bottom:1px solid #1f2b46;position:sticky;top:0;background:linear-gradient(180deg,#0b1220e6,#0b1220cc 70%,#0b122000)}
    h1{font-size:18px;margin:0}
    main{max-width:1200px;margin:0 auto;padding:20px;display:grid;gap:16px;grid-template-columns:1fr 1fr}
    .card{background:var(--card);border:1px solid #1f2b46;border-radius:16px;padding:16px}
    video,canvas{width:100%;border-radius:12px;background:#000}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .btn{background:#1c2a49;color:#e8eefc;border:1px solid #29406c;padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600;transition:all 0.2s}
    .btn:hover:not([disabled]){background:#29406c;transform:translateY(-1px)}
    .btn[disabled]{opacity:.6;cursor:not-allowed}
    .btn.success{background:var(--success);border-color:var(--success);color:#fff}
    .btn.warning{background:var(--warning);border-color:var(--warning);color:#fff}
    .btn.danger{background:var(--danger);border-color:var(--danger);color:#fff}
    .muted{color:var(--muted);font-size:13px}
    .leds{display:flex;gap:10px;align-items:center;margin:6px 0 8px}
    .led{width:16px;height:16px;border-radius:50%;opacity:.3;border:2px solid #0003;transition:all 0.3s}
    .led.red{background:#ef4444}.led.yellow{background:#f59e0b}.led.green{background:#22c55e}
    .led.on{opacity:1;box-shadow:0 0 0 4px #0002, 0 0 12px #fff2 inset}
    .tip{font-size:16px;line-height:1.4;margin-top:8px;min-height:60px}
    .meter{height:10px;border-radius:10px;background:#0f172a;border:1px solid #1f2b46;overflow:hidden}
    .meter > div{height:100%;width:0%;background:linear-gradient(90deg,#22c55e,#eab308,#ef4444);transition:width 0.3s}
    .badge{display:inline-flex;align-items:center;gap:8px;background:#0f172a;border:1px solid #1f2b46;border-radius:999px;padding:6px 10px;font-size:12px}
    .consent{position:fixed;inset:0;background:rgba(2,6,23,.8);backdrop-filter:blur(6px);display:flex;align-items:center;justify-content:center;padding:24px;z-index:1000}
    .consent .panel{max-width:680px;background:#0b1220;border:1px solid #1f2b46;border-radius:16px;padding:20px}
    .error-toast{position:fixed;top:20px;right:20px;background:var(--danger);color:#fff;padding:12px 16px;border-radius:8px;z-index:1001;transform:translateX(400px);transition:transform 0.3s}
    .error-toast.show{transform:translateX(0)}
    ul{margin:8px 0 0 18px}
    .lang-toggle{background:#1c2a49;border:1px solid #29406c;color:#e8eefc;padding:6px 12px;border-radius:8px;cursor:pointer;font-size:12px}
    @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(6,182,212,0.7)}70%{box-shadow:0 0 0 10px rgba(6,182,212,0)}100%{box-shadow:0 0 0 0 rgba(6,182,212,0)}}
    @media (max-width: 768px) {
      main { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <div class="row" style="justify-content:space-between;width:100%">
      <div style="display:flex;align-items:center;gap:12px">
        <h1 id="headerTitle">Sales Mood AI V2 🚀</h1>
        <div style="background:linear-gradient(45deg,#22c55e,#06b6d4);color:#fff;padding:4px 8px;border-radius:12px;font-size:10px;font-weight:bold">ADVANCED AI</div>
      </div>
      <div style="display:flex;gap:12px;align-items:center">
        <button id="langToggle" class="lang-toggle">🌐 EN</button>
      </div>
    </div>
  </header>

  <div id="consent" class="consent" role="dialog" aria-modal="true">
    <div class="panel">
      <h2 id="consent-title">Consimțământ pentru cameră & microfon</h2>
      <p class="muted" id="consent-desc">Analiza rulează local pe dispozitivul tău. Nu trimitem video/audio către servere.</p>
      <ul class="muted">
        <li id="consent-purpose">Scop: estimare mood + analiză cuvinte cheie pentru intent de cumpărare.</li>
        <li id="consent-signals">Semnale folosite: expresii faciale și energie vocală.</li>
        <li id="consent-limitations">Limitări: rezultatele sunt probabilistice.</li>
      </ul>
      <div class="row" style="margin-top:12px">
        <button id="agreeBtn" class="btn success">Sunt de acord și pornesc demo-ul</button>
        <button id="declineBtn" class="btn">Refuz</button>
      </div>
    </div>
  </div>

  <div id="errorToast" class="error-toast">
    <span id="errorMessage"></span>
  </div>

  <main>
    <section class="card">
      <div class="row" style="justify-content:space-between">
        <div style="display:flex;gap:8px;align-items:center">
          <div class="badge">
            <span>🔒 Privacy-by-design</span>
          </div>
          <div style="background:linear-gradient(45deg,#06b6d4,#8b5cf6);color:#fff;padding:4px 8px;border-radius:12px;font-size:10px;font-weight:bold;animation:pulse 2s infinite">
            V2 ADVANCED AI
          </div>
        </div>
        <span id="status" class="muted">Neinițiat</span>
      </div>

      <video id="video" autoplay playsinline muted></video>
      <canvas id="overlay" aria-hidden="true"></canvas>

      <div class="row" style="margin-top:10px">
        <button id="startBtn" class="btn success" disabled>Pornește analiză</button>
        <button id="stopBtn" class="btn warning" disabled>Oprește</button>
        <button id="pauseBtn" class="btn" disabled>Pauză</button>
        <span class="muted">FPS: <span id="fps">–</span></span>
      </div>
    </section>

    <aside class="card">
      <h3 style="margin:0 0 6px">Stare client</h3>
      <div class="leds">
        <div id="ledRed" class="led red" title="Bad"></div>
        <div id="ledYellow" class="led yellow" title="Neutral"></div>
        <div id="ledGreen" class="led green" title="Good"></div>
      </div>
      <div class="meter">
        <div id="moodBar"></div>
      </div>
      <div id="tip" class="tip">Tip: –</div>
      
      <!-- Real-time Analysis -->
      <div style="margin-top:16px;padding:12px;background:#0f172a;border:1px solid #1f2b46;border-radius:8px">
        <h4 style="margin:0 0 8px;font-size:14px">📊 Analiză în timp real</h4>
        <div style="display:grid;gap:8px">
          <div class="row" style="justify-content:space-between">
            <span class="muted">Potential client:</span>
            <span id="clientPotential" style="font-weight:bold;color:var(--warning)">Se analizează...</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">Putere financiară:</span>
            <span id="financialPower" style="font-weight:bold;color:var(--warning)">Se analizează...</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">Deschis la premium:</span>
            <span id="premiumOpenness" style="font-weight:bold;color:var(--warning)">Se analizează...</span>
          </div>
        </div>
      </div>

      <!-- Micro-expressions Analysis -->
      <div style="margin-top:16px;padding:12px;background:#0f172a;border:1px solid #1f2b46;border-radius:8px">
        <h4 style="margin:0 0 8px;font-size:14px">🎭 Micro-expresii</h4>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:11px">
          <div class="row" style="justify-content:space-between">
            <span class="muted">🤔 Îndoială:</span>
            <span id="doubtLevel" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">😕 Confuzie:</span>
            <span id="confusionLevel" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">🎆 Entuziasm:</span>
            <span id="excitementLevel" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">👁️ Angajament:</span>
            <span id="engagementLevel" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">😰 Stres:</span>
            <span id="stressLevel" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">💪 Încredere:</span>
            <span id="confidenceLevel" style="font-weight:bold">-</span>
          </div>
        </div>
      </div>

      <!-- Voice Stress Analysis -->
      <div style="margin-top:16px;padding:12px;background:#0f172a;border:1px solid #1f2b46;border-radius:8px">
        <h4 style="margin:0 0 8px;font-size:14px">🎤 Analiză vocală</h4>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:11px">
          <div class="row" style="justify-content:space-between">
            <span class="muted">😰 Ezitare:</span>
            <span id="voiceHesitation" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">💪 Încredere:</span>
            <span id="voiceConfidence" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">⚡ Stres vocal:</span>
            <span id="voiceStress" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">🎙️ Angajament:</span>
            <span id="vocalEngagement" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">🔊 Claritate:</span>
            <span id="voiceClarity" style="font-weight:bold">-</span>
          </div>
        </div>
      </div>

      <!-- Engagement Tracking -->
      <div style="margin-top:16px;padding:12px;background:#0f172a;border:1px solid #1f2b46;border-radius:8px">
        <h4 style="margin:0 0 8px;font-size:14px">👁️ Urmărire angajament</h4>
        <div style="margin-bottom:8px">
          <div class="row" style="justify-content:space-between;margin-bottom:4px">
            <span class="muted">Angajament general:</span>
            <span id="overallEngagement" style="font-weight:bold;color:var(--success)">-</span>
          </div>
          <div class="meter" style="height:6px">
            <div id="engagementBar" style="background:linear-gradient(90deg,#ef4444,#eab308,#22c55e)"></div>
          </div>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:11px">
          <div class="row" style="justify-content:space-between">
            <span class="muted">👁️ Contact vizual:</span>
            <span id="eyeContactLevel" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">🧠 Atenție:</span>
            <span id="attentionLevel" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">👀 Clipire:</span>
            <span id="blinkRateLevel" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">🤝 Poziția capului:</span>
            <span id="headPoseLevel" style="font-weight:bold">-</span>
          </div>
        </div>
      </div>

      <!-- Gesture Recognition -->
      <div style="margin-top:16px;padding:12px;background:#0f172a;border:1px solid #1f2b46;border-radius:8px">
        <h4 style="margin:0 0 8px;font-size:14px">👋 Analiza gesturilor</h4>
        <div style="margin-bottom:8px">
          <div class="row" style="justify-content:space-between;margin-bottom:4px">
            <span class="muted">Tip gest:</span>
            <span id="gestureType" style="font-weight:bold;color:var(--text)">-</span>
          </div>
          <div class="row" style="justify-content:space-between;margin-bottom:4px">
            <span class="muted">Postură corp:</span>
            <span id="bodyPosture" style="font-weight:bold;color:var(--text)">-</span>
          </div>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:11px">
          <div class="row" style="justify-content:space-between">
            <span class="muted">😰 Nervozitate:</span>
            <span id="nervousnessLevel" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">🤗 Deschidere:</span>
            <span id="opennessLevel" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">🚫 Defensiv:</span>
            <span id="defensivenessLevel" style="font-weight:bold">-</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted">🎆 Interes:</span>
            <span id="interestLevel" style="font-weight:bold">-</span>
          </div>
        </div>
      </div>

      <!-- Speech Analysis -->
      <div style="margin-top:16px">
        <div class="row" style="justify-content:space-between">
          <button id="toggleSpeech" class="btn" disabled>🎤 Activează recunoaștere</button>
          <span id="speechStatus" class="muted">Oprit</span>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="testAnalysis" class="btn" style="font-size:11px;padding:6px 10px">🧪 Test Analiză</button>
          <button id="generateScript" class="btn" style="font-size:11px;padding:6px 10px">📝 Script</button>
          <button id="toggleAnalytics" class="btn" style="font-size:11px;padding:6px 10px">📊 Dashboard</button>
        </div>
        <div id="transcript" style="margin-top:8px;padding:8px;background:#0f172a;border:1px solid #1f2b46;border-radius:6px;font-size:12px;max-height:100px;overflow-y:auto">
          <span class="muted">Transcrierea va apărea aici...</span>
        </div>
      </div>

      <!-- Live Recommendations -->
      <div id="liveRecommendations" style="margin-top:16px;padding:12px;background:#0f172a;border:1px solid #1f2b46;border-radius:8px;display:none">
        <h4 style="margin:0 0 8px;font-size:14px">💡 Recomandări live</h4>
        <div id="recommendationText" style="font-size:13px;line-height:1.4"></div>
      </div>
      
      <!-- V2 Advanced Features Status -->
      <div style="margin-top:16px;padding:12px;background:linear-gradient(135deg,#0f172a,#1e293b);border:1px solid #06b6d4;border-radius:8px">
        <h4 style="margin:0 0 8px;font-size:14px;color:#06b6d4">🚀 V2 Advanced AI Features</h4>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:10px">
          <div class="row" style="justify-content:space-between">
            <span class="muted" data-translate="speechAnalysis">🎤 Analiză Vocală:</span>
            <span id="v2SpeechStatus" style="font-weight:bold;color:var(--warning)">Standby</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted" data-translate="sentimentAI">🧠 AI Sentiment:</span>
            <span id="v2SentimentStatus" style="font-weight:bold;color:var(--success)">Active</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted" data-translate="predictive">📊 Predictiv:</span>
            <span id="v2PredictiveStatus" style="font-weight:bold;color:var(--success)">Learning</span>
          </div>
          <div class="row" style="justify-content:space-between">
            <span class="muted" data-translate="timingAI">⏰ Timing AI:</span>
            <span id="v2TimingStatus" style="font-weight:bold;color:var(--success)">Monitoring</span>
          </div>
        </div>
      </div>
    </aside>
  </main>

  <!-- Analytics Dashboard Modal -->
  <div id="analyticsModal" class="consent" style="display:none">
    <div class="panel" style="max-width:90vw;max-height:90vh;overflow-y:auto">
      <div class="row" style="justify-content:space-between;margin-bottom:16px">
        <h2>📊 Dashboard Analitic</h2>
        <button id="closeAnalytics" class="btn" style="padding:8px 12px">✕</button>
      </div>
      
      <!-- Performance Overview -->
      <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:16px;margin-bottom:24px">
        <div class="card" style="padding:12px;text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--success)" id="totalSessions">0</div>
          <div class="muted">Sesiuni totale</div>
        </div>
        <div class="card" style="padding:12px;text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--warning)" id="conversionRate">0%</div>
          <div class="muted">Rata de conversie</div>
        </div>
        <div class="card" style="padding:12px;text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--text)" id="avgDuration">0m</div>
          <div class="muted">Durata medie</div>
        </div>
        <div class="card" style="padding:12px;text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--success)" id="avgDealSize">$0</div>
          <div class="muted">Valoare medie deal</div>
        </div>
        <div class="card" style="padding:12px;text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--warning)" id="totalRevenue">$0</div>
          <div class="muted">Venituri totale</div>
        </div>
        <div class="card" style="padding:12px;text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--success)" id="revenuePerHour">$0</div>
          <div class="muted">Venit/oră</div>
        </div>
      </div>
      
      <!-- Enhanced Analytics Section -->
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:24px;margin-bottom:24px">
        <!-- Lead Quality & Conversion Funnel -->
        <div class="card" style="padding:16px">
          <h3 style="margin:0 0 12px;font-size:16px">📊 Funel de conversie</h3>
          <div style="display:grid;gap:8px">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <span>Total leaduri:</span>
              <span id="totalLeads" style="font-weight:bold;color:var(--text)">0</span>
            </div>
            <div style="display:flex;justify-content:space-between;align-items:center">
              <span>Leaduri calificate:</span>
              <span id="qualifiedLeads" style="font-weight:bold;color:var(--warning)">0</span>
            </div>
            <div style="display:flex;justify-content:space-between;align-items:center">
              <span>Dealuri închise:</span>
              <span id="closedDeals" style="font-weight:bold;color:var(--success)">0</span>
            </div>
            <div style="margin-top:8px;padding-top:8px;border-top:1px solid #1f2b46">
              <div style="display:flex;justify-content:space-between;align-items:center">
                <span>Rata calificare:</span>
                <span id="qualificationRate" style="font-weight:bold;color:var(--warning)">0%</span>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Deal Performance -->
        <div class="card" style="padding:16px">
          <h3 style="margin:0 0 12px;font-size:16px">💰 Performanța dealurilor</h3>
          <div style="display:grid;gap:8px">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <span>Ciclu mediu deal:</span>
              <span id="avgDealCycle" style="font-weight:bold;color:var(--text)">0 zile</span>
            </div>
            <div style="display:flex;justify-content:space-between;align-items:center">
              <span>Pipeline value:</span>
              <span id="pipelineValue" style="font-weight:bold;color:var(--warning)">$0</span>
            </div>
            <div style="display:flex;justify-content:space-between;align-items:center">
              <span>Venit proiectat:</span>
              <span id="projectedRevenue" style="font-weight:bold;color:var(--success)">$0</span>
            </div>
            <div style="display:flex;justify-content:space-between;align-items:center">
              <span>Probabilitate câștig:</span>
              <span id="winProbability" style="font-weight:bold;color:var(--success)">0%</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Performance Insights -->
      <div style="margin-bottom:24px">
        <h3>🎯 Insights de performanță</h3>
        <div id="performanceInsights" style="display:grid;gap:8px">
          <div class="muted" style="text-align:center;padding:12px">Nu există insights încă</div>
        </div>
      </div>
      
      <!-- Export Section -->
      <div style="margin-bottom:24px">
        <h3>📄 Export rapoarte</h3>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:12px">
          <div class="card" style="padding:16px;text-align:center">
            <h4 style="margin:0 0 8px;font-size:14px">📈 Raport complet performanță</h4>
            <p class="muted" style="font-size:12px;margin:0 0 12px">Include toate metricile, sesiunile și insights-urile</p>
            <button id="exportFullReport" class="btn success" style="width:100%;padding:8px">📄 Export PDF</button>
          </div>
          
          <div class="card" style="padding:16px;text-align:center">
            <h4 style="margin:0 0 8px;font-size:14px">👥 Raport profiluri clienți</h4>
            <p class="muted" style="font-size:12px;margin:0 0 12px">Analiză detaliată comportament clienți</p>
            <button id="exportClientReport" class="btn" style="width:100%;padding:8px">📄 Export PDF</button>
          </div>
          
          <div class="card" style="padding:16px;text-align:center">
            <h4 style="margin:0 0 8px;font-size:14px">📉 Raport sesiune curentă</h4>
            <p class="muted" style="font-size:12px;margin:0 0 12px">Detalii despre ultima sesiune de vanzări</p>
            <button id="exportSessionReport" class="btn" style="width:100%;padding:8px">📄 Export PDF</button>
          </div>
        </div>
      </div>
      
      <!-- Session History -->
      <div style="margin-bottom:24px">
        <h3>Istoricul sesiunilor</h3>
        <div id="sessionHistory" style="max-height:300px;overflow-y:auto">
          <div class="muted" style="text-align:center;padding:20px">Nu există sesiuni încă</div>
        </div>
      </div>
      
      <!-- Top Keywords and Client Profiles -->
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px">
        <div>
          <h3>Cuvinte cheie populare</h3>
          <div id="topKeywords" style="max-height:200px;overflow-y:auto">
            <div class="muted">Nu există date încă</div>
          </div>
        </div>
        
        <div>
          <h3>Profiluri clienți</h3>
          <div id="clientProfiles" style="max-height:200px;overflow-y:auto">
            <div class="muted">Nu există profiluri încă</div>
          </div>
        </div>
      </div>
      
      <!-- Session Outcome Form -->
      <div id="outcomeForm" style="display:none;margin-top:16px">
        <h3>Rezultatul sesiunii</h3>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px">
          <div>
            <div style="margin-bottom:12px">
              <label style="display:block;margin-bottom:4px;font-size:14px">S-a convertit clientul?</label>
              <div class="row" style="gap:8px">
                <button id="convertedYes" class="btn" style="padding:6px 12px;font-size:12px">Da</button>
                <button id="convertedNo" class="btn" style="padding:6px 12px;font-size:12px">Nu</button>
              </div>
            </div>
            <div style="margin-bottom:12px">
              <label style="display:block;margin-bottom:4px;font-size:14px">Valoarea deal-ului ($):</label>
              <input id="dealSizeInput" type="number" style="width:100%;padding:8px;background:#0f172a;border:1px solid #1f2b46;border-radius:6px;color:var(--text)" placeholder="0">
            </div>
          </div>
          <div>
            <div style="margin-bottom:12px">
              <label style="display:block;margin-bottom:4px;font-size:14px">ID Client (opțional):</label>
              <input id="clientIdInput" type="text" style="width:100%;padding:8px;background:#0f172a;border:1px solid #1f2b46;border-radius:6px;color:var(--text)" placeholder="client_123">
            </div>
            <div style="margin-bottom:12px">
              <label style="display:block;margin-bottom:4px;font-size:14px">Notețe:</label>
              <textarea id="sessionNotes" style="width:100%;height:60px;padding:8px;background:#0f172a;border:1px solid #1f2b46;border-radius:6px;color:var(--text);resize:vertical" placeholder="Note despre sesiune..."></textarea>
            </div>
          </div>
        </div>
        <button id="saveOutcome" class="btn success" style="width:100%">Salvează rezultatul</button>
      </div>
    </div>
  </div>

  <script type="module">
    // Import MediaPipe
    let FaceLandmarker, FilesetResolver;
    
    try {
      const module = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8");
      FaceLandmarker = module.FaceLandmarker;
      FilesetResolver = module.FilesetResolver;
    } catch (error) {
      console.error('Failed to load MediaPipe:', error);
      document.getElementById('errorMessage').textContent = 'Eroare la încărcarea MediaPipe';
      document.getElementById('errorToast').classList.add('show');
    }
    
    // Import jsPDF for PDF generation
    // Load jsPDF library
    let jsPDF = null;
    
    // Function to load jsPDF dynamically
    async function loadJsPDF() {
      if (jsPDF) return jsPDF;
      
      try {
        // Create script element to load jsPDF
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
        
        // Wait for script to load
        await new Promise((resolve, reject) => {
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        });
        
        // Get jsPDF from global window object
        jsPDF = window.jspdf?.jsPDF || window.jsPDF;
        
        if (!jsPDF) {
          throw new Error('jsPDF not found on window object');
        }
        
        console.log('jsPDF loaded successfully');
        return jsPDF;
        
      } catch (error) {
        console.error('Failed to load jsPDF:', error);
        throw new Error('PDF generation library could not be loaded');
      }
    }

    // Translation system
    const translations = {
      ro: {
        tips: {
          good: "Propune pachetul mediu sau întreabă bugetul.",
          neutral: "Pune o întrebare deschisă ca să clarifici nevoia.",
          bad: "Construiește încredere: oferă testimonial sau garanție."
        },
        status: {
          uninitialized: "Neinițiat",
          loading: "Se încarcă...",
          ready: "Gata",
          running: "Rulează",
          paused: "În pauză", 
          stopped: "Oprit",
          error: "Eroare"
        }
        ui: {
          startAnalysis: "Pornește analiză",
          stopAnalysis: "Oprește",
          pauseAnalysis: "Pauză",
          activateSpeech: "🎤 Activează recunoaștere vocală",
          deactivateSpeech: "🎤 Oprește recunoaștere",
          testAnalysis: "🧪 Test Analiză",
          generateScript: "📝 Script",
          openDashboard: "📊 Dashboard",
          speechAnalysis: "Analiză Vocală:",
          sentimentAI: "AI Sentiment:",
          predictive: "Predictiv:",
          timingAI: "Timing AI:",
          standby: "Standby",
          active: "Activ",
          learning: "Învățare",
          monitoring: "Monitorizare"
        },
        insights: {
          conversionRateLow: "Rata de conversie {rate}% este sub media industriei. Consideră îmbunătățirea procesului de calificare",
          conversionRateHigh: "Excelent! Rata ta de conversie {rate}% este cu {percent}% peste media industriei",
          strongDealSizes: "Valori puternice ale tranzacțiilor! Media ${amount} arată poziționarea eficientă a valorii",
          fastSalesCycle: "Ciclu de vânzări rapid! Media de {days} zile arată închiderea eficientă",
          excellentProductivity: "Productivitate excelentă! ${amount}/oră arată eficiență ridicată",
          premiumBuyersDetected: "Cumpărători premium detectați! Concentrează-te pe propuneri de valoare ridicată și exclusivitate"
        }
      },
      en: {
        tips: {
          good: "Propose mid-tier package or ask about budget.",
          neutral: "Ask an open question to clarify needs.",
          bad: "Build trust: offer testimonial or warranty."
        },
        status: {
          uninitialized: "Uninitialized",
          loading: "Loading...",
          ready: "Ready",
          running: "Running",
          paused: "Paused",
          stopped: "Stopped", 
          error: "Error"
        }
        ui: {
          startAnalysis: "Start Analysis",
          stopAnalysis: "Stop",
          pauseAnalysis: "Pause",
          activateSpeech: "🎤 Activate Speech Recognition",
          deactivateSpeech: "🎤 Stop Recognition",
          testAnalysis: "🧪 Test Analysis",
          generateScript: "📝 Script",
          openDashboard: "📊 Dashboard",
          speechAnalysis: "Speech Analysis:",
          sentimentAI: "Sentiment AI:",
          predictive: "Predictive:",
          timingAI: "Timing AI:",
          standby: "Standby",
          active: "Active",
          learning: "Learning",
          monitoring: "Monitoring"
        },
        insights: {
          conversionRateLow: "Conversion rate {rate}% is below industry average. Consider improving qualification process",
          conversionRateHigh: "Excellent! Your {rate}% conversion rate is {percent}% above industry average",
          strongDealSizes: "Strong deal sizes! Average ${amount} shows effective value positioning",
          fastSalesCycle: "Fast sales cycle! Average {days} days shows efficient closing",
          excellentProductivity: "Excellent productivity! ${amount}/hour shows high efficiency",
          premiumBuyersDetected: "Premium buyers detected! Focus on high-value propositions and exclusivity"
        }
      }
    };

    let currentLang = 'ro';

    // Enhanced keyword analysis for sales insights
    const keywordAnalysis = {
      clientPotential: {
        positive: {
          ro: ['interesat', 'vreau să știu', 'spune-mi mai mult', 'ce opțiuni', 'prețuri', 'oferte', 'când pot', 'cum funcționează', 'vreau', 'cumpăr', 'interesant', 'bun', 'sunt interesat', 'plăcește', 'perfect', 'exact ce caut'],
          en: ['interested', 'want to know', 'tell me more', 'what options', 'prices', 'offers', 'when can', 'how does it work', 'want', 'buy', 'interesting', 'good', 'perfect', 'exactly what']
        },
        negative: {
          ro: ['nu mă interesează', 'nu am timp', 'nu vreau', 'nu am nevoie', 'nu acum', 'poate altădată', 'nu sunt sigur', 'nu îmi place', 'nu este pentru mine'],
          en: ['not interested', 'no time', 'dont want', 'dont need', 'not now', 'maybe another time', 'not sure', 'not for me', 'dont like']
        }
      },
      financialPower: {
        positive: {
          ro: ['îmi permit', 'am buget', 'banii nu sunt problemă', 'investiție', 'valoare', 'calitate', 'plătesc pentru', 'permit orice', 'nu contează prețul', 'investesc', 'profit', 'bani nu sunt o problemă'],
          en: ['can afford', 'have budget', 'money not a problem', 'investment', 'value', 'quality', 'pay for', 'afford anything', 'price doesnt matter', 'invest', 'profit']
        },
        negative: {
          ro: ['scump', 'prea mult', 'nu am bani', 'buget limitat', 'nu-mi permit', 'ieftin', 'redus', 'economic', 'mai puțini bani', 'nu am fonduri'],
          en: ['expensive', 'too much', 'no money', 'limited budget', 'cant afford', 'cheap', 'discount', 'budget', 'less money', 'no funds']
        }
      },
      premium: {
        positive: {
          ro: ['cel mai bun', 'premium', 'top', 'lux', 'exclusiv', 'profesional', 'performanță', 'cea mai bună calitate', 'superior', 'excelență', 'de înaltă calitate'],
          en: ['the best', 'premium', 'top', 'luxury', 'exclusive', 'professional', 'performance', 'highest quality', 'superior', 'excellence', 'high-end']
        },
        negative: {
          ro: ['de bază', 'simplu', 'standard', 'normal', 'obișnuit', 'doar funcționalitatea', 'minimal', 'basic', 'simplist'],
          en: ['basic', 'simple', 'standard', 'normal', 'regular', 'just functionality', 'minimal', 'plain']
        }
      }
    };

    // Real-time Objection Handling Database
    const objectionDatabase = {
      price: {
        keywords: {
          ro: ['scump', 'prea mult', 'nu-mi permit', 'buget limitat', 'nu am bani', 'prea costisitor', 'pret ridicat', 'nu am fonduri', 'cost mare', 'ieftin mai'],
          en: ['expensive', 'too much', 'cant afford', 'limited budget', 'no money', 'too costly', 'high price', 'no funds', 'high cost', 'cheaper option']
        },
        responses: {
          ro: [
            'Inteleg preocuparea cu privire la pret. Sa vorbim despre valoarea pe care o obtineti...',
            'Multi clienti au avut aceeasi intrebare. Permiteti-mi sa va arat returul investitiei...',
            'Sa calculam impreuna cat va va economisi aceasta solutie pe termen lung...',
            'Avem optiuni de plata flexibile care pot face investitia mai accesibila...'
          ],
          en: [
            'I understand the price concern. Let\'s talk about the value you\'ll receive...',
            'Many clients had the same question. Let me show you the return on investment...',
            'Let\'s calculate together how much this solution will save you long-term...',
            'We have flexible payment options that can make the investment more accessible...'
          ]
        },
        followUp: {
          ro: ['Imi puteti spune care este bugetul dvs. pentru aceasta investitie?', 'Ce v-ar face sa simtiti ca investitia merita fiecare ban?'],
          en: ['Could you tell me what your budget is for this investment?', 'What would make you feel the investment is worth every penny?']
        }
      },
      time: {
        keywords: {
          ro: ['nu am timp', 'prea ocupat', 'mai tarziu', 'saptamana viitoare', 'nu acum', 'program incarcat', 'grabesc', 'nu pot acum'],
          en: ['no time', 'too busy', 'later', 'next week', 'not now', 'busy schedule', 'in a rush', 'cant now']
        },
        responses: {
          ro: [
            'Inteleg ca timpul este pretios. Exact de aceea aceasta solutie va va economisi timp...',
            'Cat timp credeti ca pierdeti zilnic cu problema actuala?',
            'Sa programam o scurta discutie de 15 minute la momentul potrivit pentru dvs...',
            'Momentul potrivit pentru a economisi timp este chiar acum...'
          ],
          en: [
            'I understand time is precious. That\'s exactly why this solution will save you time...',
            'How much time do you think you lose daily with the current problem?',
            'Let\'s schedule a brief 15-minute discussion at the right time for you...',
            'The right time to save time is right now...'
          ]
        },
        followUp: {
          ro: ['Cand ar fi cel mai bun moment pentru o discutie scurta?', 'Ce va impiedica sa luati o decizie acum?'],
          en: ['When would be the best time for a brief discussion?', 'What\'s preventing you from making a decision now?']
        }
      },
      trust: {
        keywords: {
          ro: ['nu sunt sigur', 'nu stiu', 'trebuie sa ma gandesc', 'sa verific', 'nu sunt convins', 'indoieli', 'nesigur', 'sa analizez'],
          en: ['not sure', 'dont know', 'need to think', 'check', 'not convinced', 'doubts', 'uncertain', 'analyze']
        },
        responses: {
          ro: [
            'Este normal sa aveti intrebari. Sa abordam orice nedumerire aveti...',
            'Multi clienti au fost in situatia dvs. Iata ce spun despre experienta lor...',
            'Va inteleg ezitarea. Ce informatii v-ar ajuta sa va simtiti mai confortabil?',
            'Sa va arat rezultatele concrete obtinute de alti clienti ca dvs...'
          ],
          en: [
            'It\'s normal to have questions. Let\'s address any concerns you have...',
            'Many clients were in your situation. Here\'s what they say about their experience...',
            'I understand your hesitation. What information would help you feel more comfortable?',
            'Let me show you concrete results achieved by other clients like you...'
          ]
        },
        followUp: {
          ro: ['Ce anume va face sa ezitati?', 'Ce ar trebui sa se intample pentru a va simti 100% confortabil?'],
          en: ['What exactly makes you hesitate?', 'What would need to happen for you to feel 100% comfortable?']
        }
      },
      authority: {
        keywords: {
          ro: ['sa vorbesc cu', 'sotia mea', 'partenerul', 'echipa', 'seful', 'consilier', 'sa consultez', 'nu decid singur'],
          en: ['talk to', 'my wife', 'partner', 'team', 'boss', 'advisor', 'consult', 'dont decide alone']
        },
        responses: {
          ro: [
            'Inteleg ca aceasta este o decizie importanta. Ce intrebari ar putea avea partenerii dvs.?',
            'Excelent! Sa pregatim informatiile necesare pentru discutia cu echipa dvs...',
            'Ce ar convinge partenerii dvs. ca aceasta este alegerea potrivita?',
            'Sa organizez o prezentare pentru intreaga echipa de decizie...'
          ],
          en: [
            'I understand this is an important decision. What questions might your partners have?',
            'Excellent! Let\'s prepare the necessary information for your team discussion...',
            'What would convince your partners that this is the right choice?',
            'Let me organize a presentation for the entire decision-making team...'
          ]
        },
        followUp: {
          ro: ['Cine sunt factorii de decizie si ce ii preocupa pe fiecare?', 'Cand planificati sa discutati cu echipa?'],
          en: ['Who are the decision makers and what concerns each of them?', 'When do you plan to discuss with the team?']
        }
      },
      competition: {
        keywords: {
          ro: ['alte optiuni', 'competitori', 'sa compar', 'alte oferte', 'sa verific piata', 'altcineva', 'mai ieftin'],
          en: ['other options', 'competitors', 'compare', 'other offers', 'check market', 'someone else', 'cheaper']
        },
        responses: {
          ro: [
            'Este inteleept sa comparati optiunile. Iata ce ne diferentiaza de competitie...',
            'Ce anume cautati la alti furnizori? Sa vedem cum ne comparam...',
            'Sa discutam criteriile dvs. de evaluare pentru a face alegerea potrivita...',
            'Multi clienti au comparat optiunile. Iata de ce au ales in final pe noi...'
          ],
          en: [
            'It\'s wise to compare options. Here\'s what differentiates us from competition...',
            'What exactly are you looking for with other providers? Let\'s see how we compare...',
            'Let\'s discuss your evaluation criteria to make the right choice...',
            'Many clients compared options. Here\'s why they ultimately chose us...'
          ]
        },
        followUp: {
          ro: ['Care sunt criteriile dvs. principale in luarea deciziei?', 'Ce va place cel mai mult la competitorii pe care ii considerati?'],
          en: ['What are your main criteria in making the decision?', 'What do you like most about the competitors you\'re considering?']
        }
      }
    };

    // Objection detection and response system
    let detectedObjections = {
      price: { count: 0, lastDetected: null, responses: [] },
      time: { count: 0, lastDetected: null, responses: [] },
      trust: { count: 0, lastDetected: null, responses: [] },
      authority: { count: 0, lastDetected: null, responses: [] },
      competition: { count: 0, lastDetected: null, responses: [] }
    };

    // Dynamic Script Generation System
    const scriptTemplates = {
      opening: {
        highPotential: {
          ro: [
            'Buna ziua! Ma bucur ca aveti timp pentru o discutie. Am vazut ca sunteti interesat de solutii care pot imbunatati...',
            'Salut! Apreciez ca faceti timp pentru aceasta conversatie. Vreau sa va arat cum putem optimiza...',
            'Buna! Stiu ca timpul dvs. este pretios. Sa va prezint rapid o solutie care poate revolutiona...'
          ],
          en: [
            'Hello! I\'m glad you have time for a discussion. I saw you\'re interested in solutions that can improve...',
            'Hi! I appreciate you making time for this conversation. I want to show you how we can optimize...',
            'Hello! I know your time is precious. Let me quickly present a solution that can revolutionize...'
          ]
        },
        lowPotential: {
          ro: [
            'Buna ziua! Multumesc ca imi acordati cateva minute. As vrea sa va intreb mai intai ce provocari intampinati cu...',
            'Salut! Stiu ca nu aveti mult timp, asa ca as vrea sa incep prin a intelege mai bine situatia dvs...',
            'Buna! Apreciez ca ma ascultati. Care este cea mai mare provocare cu care va confruntati zilnic?'
          ],
          en: [
            'Hello! Thank you for giving me a few minutes. I\'d like to first ask what challenges you face with...',
            'Hi! I know you don\'t have much time, so I\'d like to start by better understanding your situation...',
            'Hello! I appreciate you listening. What\'s the biggest challenge you face daily?'
          ]
        }
      },
      discovery: {
        financial: {
          ro: [
            'Pentru a va oferi cea mai buna solutie, as vrea sa inteleg mai bine bugetul dvs. pentru aceasta investitie...',
            'Ce buget ati alocat pentru rezolvarea acestei probleme in urmatoarele 6 luni?',
            'Cum evaluati de obicei returul unei investitii ca aceasta?'
          ],
          en: [
            'To offer you the best solution, I\'d like to better understand your budget for this investment...',
            'What budget have you allocated for solving this problem in the next 6 months?',
            'How do you typically evaluate the return on an investment like this?'
          ]
        },
        pain: {
          ro: [
            'Ce va costa daca nu rezolvati aceasta problema in urmatoarele 12 luni?',
            'Cum afecteaza aceasta situatie echipa dvs. zilnic?',
            'Cat timp pierdeti saptamanal din cauza acestei probleme?'
          ],
          en: [
            'What will it cost you if you don\'t solve this problem in the next 12 months?',
            'How does this situation affect your team daily?',
            'How much time do you lose weekly because of this problem?'
          ]
        }
      },
      presentation: {
        premium: {
          ro: [
            'Avand in vedere ca va concentrati pe calitate si performanta, vreau sa va prezint pachetul nostru premium...',
            'Pentru cineva cu standardele dvs. inalte, am pregativ ceva special...',
            'Stiu ca nu acceptati compromisuri in ceea ce priveste calitatea. Iata solutia noastra de top...'
          ],
          en: [
            'Given that you focus on quality and performance, I want to present our premium package...',
            'For someone with your high standards, I\'ve prepared something special...',
            'I know you don\'t compromise on quality. Here\'s our top solution...'
          ]
        },
        budgetConscious: {
          ro: [
            'Inteleg ca bugetul este important. Sa va arat cum puteti obtine rezultate excelente cu o investitie controlata...',
            'Am o solutie care oferă cel mai bun raport calitate-pret din piata...',
            'Sa incepem cu pachetul de baza care poate fi extins pe masura ce vedeti rezultatele...'
          ],
          en: [
            'I understand budget is important. Let me show you how you can get excellent results with a controlled investment...',
            'I have a solution that offers the best quality-price ratio in the market...',
            'Let\'s start with the basic package that can be expanded as you see results...'
          ]
        }
      },
      closing: {
        confident: {
          ro: [
            'Bazat pe tot ce am discutat, cred ca aceasta solutie este perfecta pentru dvs. Cand putem incepe?',
            'Aveti toate informatiile necesare. Care este urmatorul pas pentru implementare?',
            'Sunteti gata sa faceti acest pas important pentru business-ul dvs.?'
          ],
          en: [
            'Based on everything we\'ve discussed, I believe this solution is perfect for you. When can we start?',
            'You have all the necessary information. What\'s the next step for implementation?',
            'Are you ready to take this important step for your business?'
          ]
        },
        hesitant: {
          ro: [
            'Inteleg ca este o decizie importanta. Ce informatii suplimentare va-ar ajuta sa va simtiti confortabil?',
            'Ce rezerve mai aveti si cum le putem adresa impreuna?',
            'As putea sa va dau cateva zile sa va ganditi. Intre timp, ce intrebari aveti?'
          ],
          en: [
            'I understand this is an important decision. What additional information would help you feel comfortable?',
            'What reservations do you still have and how can we address them together?',
            'I could give you a few days to think about it. In the meantime, what questions do you have?'
          ]
        }
      }
    };

    // Client profiling for script selection
    const clientProfiles = {
      PREMIUM_BUYER: {
        indicators: { potential: 0.8, financial: 0.8, premium: 0.8 },
        characteristics: ['quality-focused', 'decision-maker', 'premium-oriented'],
        scriptPreferences: ['premium', 'confident', 'highPotential']
      },
      BUDGET_CONSCIOUS: {
        indicators: { potential: 0.7, financial: 0.4, premium: 0.3 },
        characteristics: ['price-sensitive', 'cautious', 'value-focused'],
        scriptPreferences: ['budgetConscious', 'hesitant', 'lowPotential']
      },
      ANALYTICAL: {
        indicators: { potential: 0.6, financial: 0.6, premium: 0.5 },
        characteristics: ['detail-oriented', 'research-heavy', 'comparison-shopper'],
        scriptPreferences: ['discovery', 'confident', 'highPotential']
      },
      SKEPTICAL: {
        indicators: { potential: 0.3, financial: 0.5, premium: 0.2 },
        characteristics: ['doubtful', 'trust-issues', 'needs-convincing'],
        scriptPreferences: ['discovery', 'hesitant', 'lowPotential']
      }
    };

    // Script generation state
    let currentScriptPhase = 'opening';
    let suggestedScripts = [];
    let clientProfileType = null;

    // Timing Recommendation System
    const timingIndicators = {
      trustBuilding: {
        positive: ['da', 'bun', 'inteleg', 'perfect', 'exact', 'asa este', 'corect', 'multumesc'],
        negative: ['nu stiu', 'nu sunt sigur', 'nu inteleg', 'confuz', 'complicat']
      },
      engagement: {
        high: ['interesant', 'wow', 'incredibil', 'fantastic', 'perfect', 'vreau sa stiu mai mult'],
        low: ['ok', 'poate', 'nu stiu', 'vedem', 'ma gandesc']
      },
      urgency: {
        high: ['urgent', 'rapid', 'cat mai repede', 'imediat', 'acum', 'maine'],
        low: ['nu grabesc', 'am timp', 'nu e urgent', 'cand pot']
      },
      buying_signals: {
        strong: ['cum cumparam', 'ce pret', 'cand incepem', 'cum platesc', 'contract', 'acord'],
        weak: ['ma gandesc', 'verific', 'poate', 'nu sunt sigur']
      }
    };

    // Timing thresholds and conditions
    const timingThresholds = {
      pricing: {
        minTrust: 0.6,
        minEngagement: 0.5,
        minConversationLength: 3,
        requiredSignals: ['interest', 'trust']
      },
      closing: {
        minTrust: 0.7,
        minEngagement: 0.6,
        minBuyingSignals: 0.4,
        minConversationLength: 5
      },
      followUp: {
        maxEngagement: 0.3,
        conversationStagnation: 8
      }
    };

    // Real-time timing state
    let timingState = {
      trustLevel: 0,
      engagementMomentum: 0,
      buyingSignals: 0,
      urgencyLevel: 0,
      conversationFlow: 'building',
      lastRecommendation: null,
      timingHistory: []
    };

    // Client Interest Warning System
    const warningIndicators = {
      disengagement: {
        verbal: ['ok', 'mm-hmm', 'da', 'uh-huh', 'poate', 'nu stiu', 'vedem', 'hmm'],
        temporal: {
          longPauses: 3000, // 3 seconds of silence
          shortResponses: 3, // responses under 3 words
          repetitiveAnswers: 2 // same answer pattern
        }
      },
      negativeSentiment: {
        frustration: ['complicat', 'confuz', 'nu inteleg', 'greu', 'dificil', 'complex'],
        rejection: ['nu ma intereseaza', 'nu vreau', 'nu e pentru mine', 'nu acum', 'nu am nevoie'],
        distraction: ['trebuie sa', 'ma grabesc', 'am de facut', 'alta data', 'nu pot acum']
      },
      physiological: {
        // Based on existing micro-expression and voice analysis
        lowEngagement: 0.3, // threshold for overall engagement
        highStress: 0.7, // stress level threshold
        lowConfidence: 0.4 // confidence threshold
      }
    };

    // Warning levels and thresholds
    const warningLevels = {
      YELLOW: {
        name: 'Atentie',
        threshold: 0.4,
        priority: 2,
        color: '#f59e0b',
        actions: ['re-engage', 'clarify']
      },
      ORANGE: {
        name: 'Risc Moderat',
        threshold: 0.6,
        priority: 3,
        color: '#ea580c',
        actions: ['pivot', 'value-focus', 'question']
      },
      RED: {
        name: 'Risc Ridicat',
        threshold: 0.8,
        priority: 4,
        color: '#dc2626',
        actions: ['emergency-recovery', 'schedule-callback', 'damage-control']
      }
    };

    // Interest loss tracking state
    let interestWarningState = {
      riskLevel: 0,
      warningHistory: [],
      lastWarning: null,
      consecutiveNegativeSignals: 0,
      engagementTrend: [],
      conversationHealth: 1.0
    };

    // Analysis state
    let analysisData = {
      clientPotential: { score: 0, keywords: [] },
      financialPower: { score: 0, keywords: [] },
      premiumOpenness: { score: 0, keywords: [] },
      conversationLength: 0,
      lastUpdate: Date.now()
    };

    // Enhanced Analytics System
    let analyticsData = {
      sessions: [],
      currentSession: null,
      clientProfiles: new Map(),
      performanceMetrics: {
        totalSessions: 0,
        conversions: 0,
        avgSessionDuration: 0,
        avgDealSize: 0,
        topKeywords: new Map(),
        // Enhanced Performance Tracking
        conversionMetrics: {
          totalLeads: 0,
          qualifiedLeads: 0,
          closedDeals: 0,
          conversionRateBySource: new Map(),
          conversionTrends: [], // Daily/weekly trends
          leadQualityScore: 0
        },
        dealMetrics: {
          totalRevenue: 0,
          dealSizes: [],
          avgDealCycle: 0, // Days from first contact to close
          dealsByCategory: new Map(),
          revenueByMonth: new Map(),
          forecasting: {
            pipeline: 0,
            projectedRevenue: 0,
            winProbability: 0
          }
        },
        performanceAnalytics: {
          topPerformingKeywords: new Map(),
          successPatterns: [],
          clientSegments: new Map(),
          roiMetrics: {
            timeInvested: 0, // minutes
            revenuePerHour: 0,
            costPerLead: 0,
            customerLifetimeValue: 0
          },
          benchmarks: {
            industryAvgConversion: 0.15, // 15% industry average
            targetConversionRate: 0.25,
            minDealSize: 1000,
            maxDealCycle: 30 // days
          }
        }
      }
    };

    // Client Profile Builder
    class ClientProfile {
      constructor(clientId) {
        this.id = clientId;
        this.sessions = [];
        this.behaviorPatterns = {
          avgPotentialScore: 0,
          avgFinancialScore: 0,
          avgPremiumScore: 0,
          preferredLanguage: 'ro',
          commonKeywords: new Map(),
          emotionalTrends: [],
          conversionProbability: 0
        };
        this.demographics = {
          estimatedAge: null,
          industry: null,
          company: null,
          notes: ''
        };
        this.interactions = {
          totalSessions: 0,
          successfulConversions: 0,
          avgSessionDuration: 0,
          lastInteraction: null,
          followUpScheduled: false
        };
        this.created = new Date();
        this.lastUpdated = new Date();
      }

      addSession(session) {
        this.sessions.push(session.id);
        this.interactions.totalSessions++;
        this.interactions.lastInteraction = session.endTime || new Date();
        this.lastUpdated = new Date();
        
        // Update behavior patterns
        this.updateBehaviorPatterns(session);
        
        // Update conversion tracking
        if (session.outcome.converted) {
          this.interactions.successfulConversions++;
        }
        
        // Update average session duration
        const totalDuration = (this.interactions.avgSessionDuration * (this.interactions.totalSessions - 1)) + session.duration;
        this.interactions.avgSessionDuration = totalDuration / this.interactions.totalSessions;
        
        // Calculate conversion probability
        this.behaviorPatterns.conversionProbability = this.interactions.successfulConversions / this.interactions.totalSessions;
      }

      updateBehaviorPatterns(session) {
        const summary = session.generateSummary();
        
        // Update average scores
        const sessionCount = this.interactions.totalSessions;
        this.behaviorPatterns.avgPotentialScore = ((this.behaviorPatterns.avgPotentialScore * (sessionCount - 1)) + summary.clientScore.potential) / sessionCount;
        this.behaviorPatterns.avgFinancialScore = ((this.behaviorPatterns.avgFinancialScore * (sessionCount - 1)) + summary.clientScore.financial) / sessionCount;
        this.behaviorPatterns.avgPremiumScore = ((this.behaviorPatterns.avgPremiumScore * (sessionCount - 1)) + summary.clientScore.premium) / sessionCount;
        
        // Update common keywords
        session.conversationData.transcript.forEach(entry => {
          if (entry.analysis) {
            Object.keys(entry.analysis).forEach(category => {
              const score = entry.analysis[category];
              if (score > 0.5) { // Only track positive signals
                const words = entry.text.toLowerCase().split(/\s+/);
                words.forEach(word => {
                  if (word.length > 3) { // Skip short words
                    const count = this.behaviorPatterns.commonKeywords.get(word) || 0;
                    this.behaviorPatterns.commonKeywords.set(word, count + 1);
                  }
                });
              }
            });
          }
        });
        
        // Track emotional trends over time
        this.behaviorPatterns.emotionalTrends.push({
          timestamp: session.endTime || new Date(),
          potential: summary.clientScore.potential,
          financial: summary.clientScore.financial,
          premium: summary.clientScore.premium,
          overall: summary.clientScore.overall
        });
        
        // Keep only last 10 emotional trend entries
        if (this.behaviorPatterns.emotionalTrends.length > 10) {
          this.behaviorPatterns.emotionalTrends = this.behaviorPatterns.emotionalTrends.slice(-10);
        }
      }

      getPersonalizedRecommendations() {
        const recommendations = [];
        
        // Based on conversion probability
        if (this.behaviorPatterns.conversionProbability > 0.7) {
          recommendations.push('🌟 CLIENT FIDEL - Abordeaza direct cu oferte premium');
        } else if (this.behaviorPatterns.conversionProbability < 0.3 && this.interactions.totalSessions > 2) {
          recommendations.push('⚠️ CLIENT DIFICIL - Folosește abordare consultativă');
        }
        
        // Based on financial patterns
        if (this.behaviorPatterns.avgFinancialScore > 0.7) {
          recommendations.push('💰 PUTERE FINANCIARĂ RIDICATĂ - Prezintă valoarea, nu prețul');
        } else if (this.behaviorPatterns.avgFinancialScore < 0.3) {
          recommendations.push('💡 SENSIBIL LA PREȚ - Oferă opțiuni de plată flexibile');
        }
        
        // Based on premium openness
        if (this.behaviorPatterns.avgPremiumScore > 0.6) {
          recommendations.push('✨ DESCHIS LA PREMIUM - Subliniază exclusivitatea și calitatea');
        }
        
        // Based on interaction frequency
        const daysSinceLastInteraction = this.interactions.lastInteraction ? 
          Math.floor((new Date() - this.interactions.lastInteraction) / (1000 * 60 * 60 * 24)) : 0;
        
        if (daysSinceLastInteraction > 7 && !this.interactions.followUpScheduled) {
          recommendations.push('📞 URMĂRIRE NECESARĂ - Programează un follow-up');
        }
        
        return recommendations;
      }

      getProfileSummary() {
        return {
          id: this.id,
          totalSessions: this.interactions.totalSessions,
          conversionRate: (this.behaviorPatterns.conversionProbability * 100).toFixed(1),
          avgScores: {
            potential: (this.behaviorPatterns.avgPotentialScore * 100).toFixed(0),
            financial: (this.behaviorPatterns.avgFinancialScore * 100).toFixed(0),
            premium: (this.behaviorPatterns.avgPremiumScore * 100).toFixed(0)
          },
          topKeywords: Array.from(this.behaviorPatterns.commonKeywords.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5)
            .map(([word, count]) => ({ word, count })),
          lastInteraction: this.interactions.lastInteraction,
          recommendations: this.getPersonalizedRecommendations()
        };
      }
    }

    // Session tracking class
    class SalesSession {
      constructor() {
        this.id = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        this.startTime = new Date();
        this.endTime = null;
        this.duration = 0;
        this.clientData = {
          potential: { scores: [], avgScore: 0, trend: 'neutral' },
          financial: { scores: [], avgScore: 0, trend: 'neutral' },
          premium: { scores: [], avgScore: 0, trend: 'neutral' }
        };
        this.conversationData = {
          transcript: [],
          keywords: [],
          emotionalStates: [],
          recommendations: []
        };
        this.outcome = {
          converted: false,
          dealSize: 0,
          followUpScheduled: false,
          notes: ''
        };
        this.metadata = {
          language: currentLang,
          browser: navigator.userAgent,
          timestamp: this.startTime.toISOString()
        };
      }

      addScoreUpdate(category, score) {
        const timestamp = Date.now();
        this.clientData[category].scores.push({ score, timestamp });
        this.updateTrends(category);
      }

      updateTrends(category) {
        const scores = this.clientData[category].scores;
        if (scores.length < 2) return;
        
        const recent = scores.slice(-5); // Last 5 scores
        const avgRecent = recent.reduce((sum, s) => sum + s.score, 0) / recent.length;
        const avgEarlier = scores.slice(0, -5).reduce((sum, s) => sum + s.score, 0) / Math.max(1, scores.length - 5);
        
        if (avgRecent > avgEarlier + 0.1) {
          this.clientData[category].trend = 'improving';
        } else if (avgRecent < avgEarlier - 0.1) {
          this.clientData[category].trend = 'declining';
        } else {
          this.clientData[category].trend = 'stable';
        }
        
        this.clientData[category].avgScore = avgRecent;
      }

      addTranscript(text, analysis) {
        this.conversationData.transcript.push({
          text,
          timestamp: Date.now(),
          analysis: { ...analysis }
        });
      }

      addRecommendation(recommendation) {
        this.conversationData.recommendations.push({
          text: recommendation,
          timestamp: Date.now()
        });
      }

      addObjection(objectionType, response) {
        if (!this.conversationData.objections) {
          this.conversationData.objections = [];
        }
        this.conversationData.objections.push({
          type: objectionType,
          response: response,
          timestamp: Date.now()
        });
      }

      addScript(scriptData) {
        if (!this.conversationData.scripts) {
          this.conversationData.scripts = [];
        }
        this.conversationData.scripts.push({
          text: scriptData.text,
          phase: scriptData.phase,
          profile: scriptData.profile,
          category: scriptData.category,
          timestamp: Date.now()
        });
      }

      addTimingData(timingData) {
        if (!this.conversationData.timing) {
          this.conversationData.timing = [];
        }
        this.conversationData.timing.push(timingData);
      }

      endSession() {
        this.endTime = new Date();
        this.duration = this.endTime - this.startTime;
        
        // Calculate final averages
        ['potential', 'financial', 'premium'].forEach(category => {
          const scores = this.clientData[category].scores;
          if (scores.length > 0) {
            this.clientData[category].avgScore = scores.reduce((sum, s) => sum + s.score, 0) / scores.length;
          }
        });
        
        return this.generateSummary();
      }

      generateSummary() {
        const summary = {
          sessionId: this.id,
          duration: Math.round(this.duration / 1000 / 60), // minutes
          clientScore: {
            potential: this.clientData.potential.avgScore,
            financial: this.clientData.financial.avgScore,
            premium: this.clientData.premium.avgScore,
            overall: (this.clientData.potential.avgScore + this.clientData.financial.avgScore + this.clientData.premium.avgScore) / 3
          },
          keyInsights: this.extractKeyInsights(),
          recommendations: this.conversationData.recommendations.slice(-3), // Last 3 recommendations
          outcome: this.outcome
        };
        return summary;
      }

      extractKeyInsights() {
        const insights = [];
        
        // Trend insights
        ['potential', 'financial', 'premium'].forEach(category => {
          const data = this.clientData[category];
          if (data.trend === 'improving') {
            insights.push(`${category} interest increased during conversation`);
          } else if (data.trend === 'declining') {
            insights.push(`${category} interest decreased - may need different approach`);
          }
        });
        
        // Score insights
        const scores = {
          potential: this.clientData.potential.avgScore,
          financial: this.clientData.financial.avgScore,
          premium: this.clientData.premium.avgScore
        };
        
        if (scores.potential > 0.7 && scores.financial > 0.7) {
          insights.push('High-value prospect - strong potential and financial capability');
        }
        
        if (scores.premium > 0.7) {
          insights.push('Open to premium offerings - suggest high-end solutions');
        }
        
        if (scores.potential < 0.3) {
          insights.push('Low interest detected - consider qualification or nurturing approach');
        }
        
        return insights;
      }

      // Enhanced Performance Tracking Methods
      addPerformanceData(type, data) {
        if (!this.performanceData) {
          this.performanceData = {
            leadSource: 'direct',
            leadQuality: 0,
            touchpoints: [],
            engagementScore: 0,
            timeToConversion: 0,
            objectionTypes: [],
            closingTechniques: []
          };
        }
        
        this.performanceData[type] = data;
      }
      
      calculateLeadQuality() {
        if (!this.performanceData) return 0;
        
        let qualityScore = 0;
        
        // Score based on engagement level
        const avgEngagement = this.conversationData.emotionalStates.length > 0 ?
          this.conversationData.emotionalStates.reduce((sum, state) => sum + (state.engagement || 0), 0) / this.conversationData.emotionalStates.length : 0;
        qualityScore += avgEngagement * 0.3;
        
        // Score based on conversation length
        const conversationScore = Math.min(this.conversationData.transcript.length / 20, 1); // Cap at 20 interactions
        qualityScore += conversationScore * 0.2;
        
        // Score based on client potential
        qualityScore += this.clientData.potential.avgScore * 0.3;
        
        // Score based on financial capability
        qualityScore += this.clientData.financial.avgScore * 0.2;
        
        return Math.min(qualityScore, 1);
      }
      
      calculateDealCycle() {
        if (!this.outcome.converted || !this.endTime) return 0;
        
        const cycleDays = Math.ceil((this.endTime - this.startTime) / (1000 * 60 * 60 * 24));
        return cycleDays;
      }
      
      identifySuccessPatterns() {
        const patterns = [];
        
        if (this.outcome.converted) {
          // Analyze what led to success
          if (this.clientData.premium.avgScore > 0.6) {
            patterns.push('premium_buyer');
          }
          
          if (this.conversationData.transcript.length > 15) {
            patterns.push('long_conversation');
          }
          
          if (this.clientData.financial.avgScore > 0.7) {
            patterns.push('high_financial_power');
          }
          
          // Analyze timing of conversion
          if (this.duration < 10 * 60 * 1000) { // Less than 10 minutes
            patterns.push('quick_close');
          } else if (this.duration > 30 * 60 * 1000) { // More than 30 minutes
            patterns.push('consultative_close');
          }
        }
        
        return patterns;
      }
    }

    // DOM elements
    const els = {
      consent: document.getElementById('consent'),
      agreeBtn: document.getElementById('agreeBtn'),
      declineBtn: document.getElementById('declineBtn'),
      video: document.getElementById('video'),
      overlay: document.getElementById('overlay'),
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      status: document.getElementById('status'),
      fps: document.getElementById('fps'),
      moodBar: document.getElementById('moodBar'),
      ledRed: document.getElementById('ledRed'),
      ledYellow: document.getElementById('ledYellow'),
      ledGreen: document.getElementById('ledGreen'),
      tip: document.getElementById('tip'),
      langToggle: document.getElementById('langToggle'),
      toggleSpeech: document.getElementById('toggleSpeech'),
      speechStatus: document.getElementById('speechStatus'),
      errorToast: document.getElementById('errorToast'),
      errorMessage: document.getElementById('errorMessage'),
      // Analysis elements
      clientPotential: document.getElementById('clientPotential'),
      financialPower: document.getElementById('financialPower'),
      premiumOpenness: document.getElementById('premiumOpenness'),
      transcript: document.getElementById('transcript'),
      liveRecommendations: document.getElementById('liveRecommendations'),
      recommendationText: document.getElementById('recommendationText'),
      testAnalysis: document.getElementById('testAnalysis'),
      generateScript: document.getElementById('generateScript'),
      // Micro-expressions elements
      doubtLevel: document.getElementById('doubtLevel'),
      confusionLevel: document.getElementById('confusionLevel'),
      excitementLevel: document.getElementById('excitementLevel'),
      engagementLevel: document.getElementById('engagementLevel'),
      stressLevel: document.getElementById('stressLevel'),
      confidenceLevel: document.getElementById('confidenceLevel'),
      // Voice stress analysis elements
      voiceHesitation: document.getElementById('voiceHesitation'),
      voiceConfidence: document.getElementById('voiceConfidence'),
      voiceStress: document.getElementById('voiceStress'),
      vocalEngagement: document.getElementById('vocalEngagement'),
      voiceClarity: document.getElementById('voiceClarity'),
      // Engagement tracking elements
      overallEngagement: document.getElementById('overallEngagement'),
      engagementBar: document.getElementById('engagementBar'),
      eyeContactLevel: document.getElementById('eyeContactLevel'),
      attentionLevel: document.getElementById('attentionLevel'),
      blinkRateLevel: document.getElementById('blinkRateLevel'),
      headPoseLevel: document.getElementById('headPoseLevel'),
      // Gesture recognition elements
      gestureType: document.getElementById('gestureType'),
      bodyPosture: document.getElementById('bodyPosture'),
      nervousnessLevel: document.getElementById('nervousnessLevel'),
      opennessLevel: document.getElementById('opennessLevel'),
      defensivenessLevel: document.getElementById('defensivenessLevel'),
      interestLevel: document.getElementById('interestLevel'),
      // Analytics dashboard elements
      toggleAnalytics: document.getElementById('toggleAnalytics'),
      analyticsModal: document.getElementById('analyticsModal'),
      closeAnalytics: document.getElementById('closeAnalytics'),
      totalSessions: document.getElementById('totalSessions'),
      conversionRate: document.getElementById('conversionRate'),
      avgDuration: document.getElementById('avgDuration'),
      avgDealSize: document.getElementById('avgDealSize'),
      sessionHistory: document.getElementById('sessionHistory'),
      topKeywords: document.getElementById('topKeywords'),
      clientProfiles: document.getElementById('clientProfiles'),
      outcomeForm: document.getElementById('outcomeForm'),
      convertedYes: document.getElementById('convertedYes'),
      convertedNo: document.getElementById('convertedNo'),
      dealSizeInput: document.getElementById('dealSizeInput'),
      clientIdInput: document.getElementById('clientIdInput'),
      sessionNotes: document.getElementById('sessionNotes'),
      saveOutcome: document.getElementById('saveOutcome'),
      // PDF Export elements
      exportFullReport: document.getElementById('exportFullReport'),
      exportClientReport: document.getElementById('exportClientReport'),
      exportSessionReport: document.getElementById('exportSessionReport')
    };

    // State variables
    let stream = null;
    let audioCtx, analyser, audioData;
    let faceLandmarker = null;
    let running = false;
    let paused = false;
    let isAnalyzing = false;
    let lastFrameTs = performance.now();
    let recognition = null;
    let isListening = false;

    const MODEL_URL = "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task";

    // Utility functions
    function setStatus(key) {
      const status = translations[currentLang].status[key] || key;
      els.status.textContent = status;
    }

    function clamp01(x) {
      return Math.max(0, Math.min(1, x));
    }

    function showError(message) {
      console.error(message);
      els.errorMessage.textContent = message;
      els.errorToast.classList.add('show');
      setTimeout(() => els.errorToast.classList.remove('show'), 5000);
    }

    function setLED(state) {
      els.ledRed.classList.toggle('on', state === 'bad');
      els.ledYellow.classList.toggle('on', state === 'neutral');
      els.ledGreen.classList.toggle('on', state === 'good');
    }

    function setTip(state) {
      const tips = translations[currentLang].tips;
      els.tip.textContent = "Tip: " + tips[state];
    }

    // Enhanced analysis functions
    // Enhanced analysis functions
    function analyzeKeywords(text) {
      if (!text) return;
      
      console.log('Analyzing text:', text); // Debug log
      
      const words = text.toLowerCase().split(/\s+/);
      const lang = currentLang;
      analysisData.conversationLength += words.length;
      
      // Store analysis results for session tracking
      const analysisResults = {};
      
      // Analyze each category
      ['clientPotential', 'financialPower', 'premium'].forEach(category => {
        // Ensure the category exists in keywordAnalysis
        if (!keywordAnalysis[category]) {
          console.error(`Category ${category} not found in keywordAnalysis`);
          return;
        }
        
        // Ensure the category exists in analysisData
        if (!analysisData[category]) {
          analysisData[category] = { score: 0, keywords: [] };
        }
        
        words.forEach(word => {
          // Check positive keywords - improved matching
          const positiveMatch = keywordAnalysis[category].positive[lang] && 
            keywordAnalysis[category].positive[lang].some(kw => {
              // Exact match or phrase match
              return word.includes(kw.toLowerCase()) || text.toLowerCase().includes(kw.toLowerCase());
            });
          if (positiveMatch) {
            const existingKeyword = analysisData[category].keywords.find(k => k.word === word);
            if (!existingKeyword) {
              analysisData[category].keywords.push({ word, sentiment: 'positive', timestamp: Date.now() });
              console.log(`Added positive ${category} keyword:`, word); // Debug log
            }
          }
          
          // Check negative keywords - improved matching
          const negativeMatch = keywordAnalysis[category].negative[lang] &&
            keywordAnalysis[category].negative[lang].some(kw => {
              // Exact match or phrase match
              return word.includes(kw.toLowerCase()) || text.toLowerCase().includes(kw.toLowerCase());
            });
          if (negativeMatch) {
            const existingKeyword = analysisData[category].keywords.find(k => k.word === word);
            if (!existingKeyword) {
              analysisData[category].keywords.push({ word, sentiment: 'negative', timestamp: Date.now() });
              console.log(`Added negative ${category} keyword:`, word); // Debug log
            }
          }
        });
        
        // Calculate scores with improved algorithm
        const keywords = analysisData[category].keywords;
        if (keywords && keywords.length > 0) {
          const positive = keywords.filter(k => k.sentiment === 'positive').length;
          const negative = keywords.filter(k => k.sentiment === 'negative').length;
          
          // Improved scoring: give more weight to having any positive keywords
          let newScore = 0;
          if (positive > 0 && negative === 0) {
            newScore = Math.min(0.8, 0.3 + (positive * 0.1)); // Start at 30% and increase
          } else if (positive > 0 && negative > 0) {
            newScore = positive / (positive + negative);
          } else if (negative > 0 && positive === 0) {
            newScore = Math.max(0.1, 0.3 - (negative * 0.1)); // Start at 30% and decrease
          }
          
          analysisData[category].score = newScore;
          console.log(`${category} score updated:`, newScore, 'from', positive, 'positive and', negative, 'negative keywords'); // Debug log
          
          // Store for analytics
          analysisResults[category] = newScore;
          
          // Update current session if active
          if (analyticsData.currentSession) {
            const categoryMap = {
              clientPotential: 'potential',
              financialPower: 'financial',
              premiumOpenness: 'premium'
            };
            analyticsData.currentSession.addScoreUpdate(categoryMap[category], newScore);
          }
      els.startBtn.textContent = translations[currentLang].ui.startAnalysis;
      els.stopBtn.textContent = translations[currentLang].ui.stopAnalysis;
      els.pauseBtn.textContent = translations[currentLang].ui.pauseAnalysis;
      els.toggleSpeech.textContent = translations[currentLang].ui.activateSpeech;
      els.testAnalysis.textContent = translations[currentLang].ui.testAnalysis;
      els.generateScript.textContent = translations[currentLang].ui.generateScript;
      els.toggleAnalytics.textContent = translations[currentLang].ui.openDashboard;
      
      // Update V2 Advanced AI Features section
      const v2SpeechStatus = document.getElementById('v2SpeechStatus');
      const v2SentimentStatus = document.getElementById('v2SentimentStatus');
      const v2PredictiveStatus = document.getElementById('v2PredictiveStatus');
      const v2TimingStatus = document.getElementById('v2TimingStatus');
      
      if (v2SpeechStatus && v2SpeechStatus.textContent === 'Standby') {
        v2SpeechStatus.textContent = translations[currentLang].ui.standby;
      }
      if (v2SentimentStatus && v2SentimentStatus.textContent === 'Active') {
        v2SentimentStatus.textContent = translations[currentLang].ui.active;
      }
      if (v2PredictiveStatus && v2PredictiveStatus.textContent === 'Learning') {
        v2PredictiveStatus.textContent = translations[currentLang].ui.learning;
      }
      if (v2TimingStatus && v2TimingStatus.textContent === 'Monitoring') {
        v2TimingStatus.textContent = translations[currentLang].ui.monitoring;
      }
      
      // Update labels with data-translate attributes
      document.querySelectorAll('[data-translate]').forEach(element => {
        const key = element.getAttribute('data-translate');
        if (translations[currentLang].ui[key]) {
          element.textContent = element.textContent.replace(/[^🎤🧠📊⏰]+/, ' ' + translations[currentLang].ui[key].replace(/[🎤🧠📊⏰]/g, '').trim() + ':');
        }
      });
      
      // Detect and handle objections
      detectObjections(text);
      
      // Analyze conversation timing
      analyzeConversationTiming(text);
      
      // Auto-generate personalized scripts
      autoGenerateScripts();
      
      updateAnalysisDisplay();
      
      // Update dashboard if open
      if (els.analyticsModal.style.display === 'flex') {
        updateDashboardDisplay();
      }
      generateLiveRecommendations();
    }

    function updateAnalysisDisplay() {
      // Client Potential
      const clientScore = analysisData.clientPotential.score;
      const clientTexts = currentLang === 'ro' ? 
        { high: 'ÎNALT 🔥', med: 'MEDIU 🟡', low: 'SCĂZUT 🔴', analyzing: 'Se analizează...', none: 'Aștept vorbire...' } :
        { high: 'HIGH 🔥', med: 'MEDIUM 🟡', low: 'LOW 🔴', analyzing: 'Analyzing...', none: 'Waiting for speech...' };
      
      let clientText, clientColor;
      if (!isAnalyzing) {
        clientText = clientTexts.none;
        clientColor = 'var(--muted)';
      } else if (clientScore >= 0.7) {
        clientText = clientTexts.high;
        clientColor = 'var(--success)';
      } else if (clientScore >= 0.4) {
        clientText = clientTexts.med;
        clientColor = 'var(--warning)';
      } else if (clientScore > 0.1) {
        clientText = clientTexts.low;
        clientColor = 'var(--danger)';
      } else {
        clientText = clientTexts.analyzing;
        clientColor = 'var(--muted)';
      }
      
      els.clientPotential.textContent = clientText;
      els.clientPotential.style.color = clientColor;

      // Financial Power
      const finScore = analysisData.financialPower.score;
      const finTexts = currentLang === 'ro' ? 
        { high: 'PUTERNICĂ 💰', med: 'MODERATĂ 🟡', low: 'SLABĂ 🔴', analyzing: 'Se analizează...', none: 'Aștept vorbire...' } :
        { high: 'STRONG 💰', med: 'MODERATE 🟡', low: 'WEAK 🔴', analyzing: 'Analyzing...', none: 'Waiting for speech...' };
      
      let finText, finColor;
      if (!isAnalyzing) {
        finText = finTexts.none;
        finColor = 'var(--muted)';
      } else if (finScore >= 0.7) {
        finText = finTexts.high;
        finColor = 'var(--success)';
      } else if (finScore >= 0.4) {
        finText = finTexts.med;
        finColor = 'var(--warning)';
      } else if (finScore > 0.1) {
        finText = finTexts.low;
        finColor = 'var(--danger)';
      } else {
        finText = finTexts.analyzing;
        finColor = 'var(--muted)';
      }
      
      els.financialPower.textContent = finText;
      els.financialPower.style.color = finColor;

      // Premium Openness
      const premScore = analysisData.premiumOpenness.score;
      const premTexts = currentLang === 'ro' ? 
        { high: 'FOARTE DESCHIS ✨', med: 'DESCHIS 🟡', low: 'RETICENT 🔴', analyzing: 'Se analizează...', none: 'Aștept vorbire...' } :
        { high: 'VERY OPEN ✨', med: 'OPEN 🟡', low: 'RELUCTANT 🔴', analyzing: 'Analyzing...', none: 'Waiting for speech...' };
      
      let premText, premColor;
      if (!isAnalyzing) {
        premText = premTexts.none;
        premColor = 'var(--muted)';
      } else if (premScore >= 0.7) {
        premText = premTexts.high;
        premColor = 'var(--success)';
      } else if (premScore >= 0.4) {
        premText = premTexts.med;
        premColor = 'var(--warning)';
      } else if (premScore > 0.1) {
        premText = premTexts.low;
        premColor = 'var(--danger)';
      } else {
        premText = premTexts.analyzing;
        premColor = 'var(--muted)';
      }
      
      els.premiumOpenness.textContent = premText;
      els.premiumOpenness.style.color = premColor;
    }

    // Objection Detection and Response Function
    function detectObjections(text) {
      if (!text) return;
      
      const textLower = text.toLowerCase();
      const lang = currentLang;
      const now = Date.now();
      
      // Check each objection type
      Object.keys(objectionDatabase).forEach(objectionType => {
        const keywords = objectionDatabase[objectionType].keywords[lang] || [];
        
        // Check if any keywords match
        const hasObjection = keywords.some(keyword => 
          textLower.includes(keyword.toLowerCase())
        );
        
        if (hasObjection) {
          // Update objection tracking
          detectedObjections[objectionType].count++;
          detectedObjections[objectionType].lastDetected = now;
          
          // Get appropriate response
          const responses = objectionDatabase[objectionType].responses[lang] || [];
          const followUps = objectionDatabase[objectionType].followUp[lang] || [];
          
          if (responses.length > 0) {
            // Select response based on frequency (different response each time)
            const responseIndex = (detectedObjections[objectionType].count - 1) % responses.length;
            const selectedResponse = responses[responseIndex];
            
            // Store the response suggestion
            detectedObjections[objectionType].responses.push({
              text: selectedResponse,
              timestamp: now,
              followUp: followUps[responseIndex % followUps.length] || null
            });
            
            console.log(`Objection detected: ${objectionType}`, selectedResponse);
            
            // Show objection handling in UI
            showObjectionAlert(objectionType, selectedResponse, followUps[responseIndex % followUps.length]);
            
            // Add to session tracking
            if (analyticsData.currentSession) {
              analyticsData.currentSession.addObjection(objectionType, selectedResponse);
            }
          }
        }
      });
    }

    // Show objection alert to sales professional
    function showObjectionAlert(objectionType, response, followUp) {
      // Create objection alert element if it doesn't exist
      let objectionAlert = document.getElementById('objectionAlert');
      if (!objectionAlert) {
        objectionAlert = document.createElement('div');
        objectionAlert.id = 'objectionAlert';
        objectionAlert.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: linear-gradient(135deg, #dc2626, #ef4444);
          color: white;
          padding: 16px;
          border-radius: 12px;
          max-width: 400px;
          box-shadow: 0 8px 25px rgba(220, 38, 38, 0.3);
          z-index: 1000;
          border: 1px solid rgba(255, 255, 255, 0.2);
          backdrop-filter: blur(10px);
          animation: slideInRight 0.3s ease-out;
        `;
        document.body.appendChild(objectionAlert);
        
        // Add CSS animation
        if (!document.getElementById('objectionStyles')) {
          const style = document.createElement('style');
          style.id = 'objectionStyles';
          style.textContent = `
            @keyframes slideInRight {
              from { transform: translateX(100%); opacity: 0; }
              to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
              from { transform: translateX(0); opacity: 1; }
              to { transform: translateX(100%); opacity: 0; }
            }
          `;
          document.head.appendChild(style);
        }
      }
      
      // Objection type emojis
      const objectionEmojis = {
        price: '💰',
        time: '⏰',
        trust: '🤔',
        authority: '👥',
        competition: '🏆'
      };
      
      // Objection type names
      const objectionNames = {
        ro: {
          price: 'Objecție de Preț',
          time: 'Objecție de Timp',
          trust: 'Objecție de Încredere',
          authority: 'Objecție de Autoritate',
          competition: 'Objecție de Competiție'
        },
        en: {
          price: 'Price Objection',
          time: 'Time Objection',
          trust: 'Trust Objection',
          authority: 'Authority Objection',
          competition: 'Competition Objection'
        }
      };
      
      const objectionName = objectionNames[currentLang][objectionType] || objectionType;
      const emoji = objectionEmojis[objectionType] || '⚠️';
      
      objectionAlert.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-weight: bold; font-size: 14px;">
          <span style="font-size: 18px;">${emoji}</span>
          <span style="text-transform: uppercase; letter-spacing: 0.5px;">${objectionName}</span>
          <button onclick="this.parentElement.parentElement.style.display='none'" 
                  style="margin-left: auto; background: none; border: none; color: white; font-size: 18px; cursor: pointer; padding: 0;">
            ×
          </button>
        </div>
        <div style="background: rgba(0,0,0,0.2); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
          <div style="font-size: 12px; opacity: 0.8; margin-bottom: 4px;">RĂSPUNS SUGERAT:</div>
          <div style="font-size: 13px; line-height: 1.4;">${response}</div>
        </div>
        ${followUp ? `
        <div style="background: rgba(0,0,0,0.1); padding: 10px; border-radius: 6px; border-left: 3px solid rgba(255,255,255,0.6);">
          <div style="font-size: 11px; opacity: 0.7; margin-bottom: 3px;">ÎNTREBARE DE URMĂRIRE:</div>
          <div style="font-size: 12px; font-style: italic;">${followUp}</div>
        </div>
        ` : ''}
      `;
      
      // Auto-hide after 12 seconds
      setTimeout(() => {
        if (objectionAlert && objectionAlert.parentNode) {
          objectionAlert.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => {
            if (objectionAlert.parentNode) {
              objectionAlert.parentNode.removeChild(objectionAlert);
            }
          }, 300);
        }
      }, 12000);
    }

    // Dynamic Script Generation Functions
    function determineClientProfile() {
      const scores = {
        potential: analysisData.clientPotential.score,
        financial: analysisData.financialPower.score,
        premium: analysisData.premiumOpenness.score
      };
      
      // Calculate profile match scores
      let bestMatch = null;
      let bestScore = 0;
      
      Object.keys(clientProfiles).forEach(profileType => {
        const profile = clientProfiles[profileType];
        const matchScore = (
          Math.abs(scores.potential - profile.indicators.potential) +
          Math.abs(scores.financial - profile.indicators.financial) +
          Math.abs(scores.premium - profile.indicators.premium)
        ) / 3;
        
        // Lower matchScore means better match (less difference)
        const finalScore = 1 - matchScore;
        
        if (finalScore > bestScore) {
          bestScore = finalScore;
          bestMatch = profileType;
        }
      });
      
      if (bestScore > 0.6) { // Only assign if confident match
        clientProfileType = bestMatch;
        console.log(`Client profile determined: ${bestMatch} (confidence: ${(bestScore * 100).toFixed(1)}%)`);
        return bestMatch;
      }
      
      return null;
    }
    
    function generatePersonalizedScript(phase = currentScriptPhase) {
      const profile = determineClientProfile();
      const lang = currentLang;
      
      if (!profile || !scriptTemplates[phase]) {
        return null;
      }
      
      const profileConfig = clientProfiles[profile];
      const preferences = profileConfig.scriptPreferences;
      
      // Find matching script category based on profile preferences
      let selectedCategory = null;
      let scripts = [];
      
      for (const preference of preferences) {
        if (scriptTemplates[phase][preference]) {
          selectedCategory = preference;
          scripts = scriptTemplates[phase][preference][lang] || [];
          break;
        }
      }
      
      if (scripts.length === 0) {
        // Fallback to any available scripts for this phase
        const categories = Object.keys(scriptTemplates[phase]);
        if (categories.length > 0) {
          selectedCategory = categories[0];
          scripts = scriptTemplates[phase][selectedCategory][lang] || [];
        }
      }
      
      if (scripts.length > 0) {
        // Select script based on conversation progress
        const sessionLength = analyticsData.currentSession ? 
          analyticsData.currentSession.conversationData.transcript.length : 0;
        const scriptIndex = sessionLength % scripts.length;
        
        return {
          text: scripts[scriptIndex],
          category: selectedCategory,
          phase: phase,
          profile: profile,
          confidence: 0.8
        };
      }
      
      return null;
    }
    
    function updateScriptPhase(newPhase) {
      if (['opening', 'discovery', 'presentation', 'closing'].includes(newPhase)) {
        currentScriptPhase = newPhase;
        
        // Generate new script for the phase
        const script = generatePersonalizedScript(newPhase);
        if (script) {
          showScriptSuggestion(script);
        }
      }
    }
    
    function showScriptSuggestion(script) {
      // Create script suggestion element if it doesn't exist
      let scriptAlert = document.getElementById('scriptSuggestion');
      if (!scriptAlert) {
        scriptAlert = document.createElement('div');
        scriptAlert.id = 'scriptSuggestion';
        scriptAlert.style.cssText = `
          position: fixed;
          bottom: 20px;
          right: 20px;
          background: linear-gradient(135deg, #059669, #10b981);
          color: white;
          padding: 16px;
          border-radius: 12px;
          max-width: 450px;
          box-shadow: 0 8px 25px rgba(5, 150, 105, 0.3);
          z-index: 1000;
          border: 1px solid rgba(255, 255, 255, 0.2);
          backdrop-filter: blur(10px);
          animation: slideInUp 0.3s ease-out;
        `;
        document.body.appendChild(scriptAlert);
        
        // Add CSS animation for script suggestions
        if (!document.getElementById('scriptStyles')) {
          const style = document.createElement('style');
          style.id = 'scriptStyles';
          style.textContent = `
            @keyframes slideInUp {
              from { transform: translateY(100%); opacity: 0; }
              to { transform: translateY(0); opacity: 1; }
            }
            @keyframes slideOutDown {
              from { transform: translateY(0); opacity: 1; }
              to { transform: translateY(100%); opacity: 0; }
            }
          `;
          document.head.appendChild(style);
        }
      }
      
      // Phase emojis
      const phaseEmojis = {
        opening: '🚀',
        discovery: '🔍',
        presentation: '💼',
        closing: '🎯'
      };
      
      // Phase names
      const phaseNames = {
        ro: {
          opening: 'Deschidere',
          discovery: 'Descoperire',
          presentation: 'Prezentare',
          closing: 'Inchidere'
        },
        en: {
          opening: 'Opening',
          discovery: 'Discovery',
          presentation: 'Presentation',
          closing: 'Closing'
        }
      };
      
      const phaseName = phaseNames[currentLang][script.phase] || script.phase;
      const emoji = phaseEmojis[script.phase] || '💬';
      
      scriptAlert.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-weight: bold; font-size: 14px;">
          <span style="font-size: 18px;">${emoji}</span>
          <span style="text-transform: uppercase; letter-spacing: 0.5px;">${phaseName} - ${script.profile}</span>
          <button onclick="this.parentElement.parentElement.style.display='none'" 
                  style="margin-left: auto; background: none; border: none; color: white; font-size: 18px; cursor: pointer; padding: 0;">
            ×
          </button>
        </div>
        <div style="background: rgba(0,0,0,0.2); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
          <div style="font-size: 12px; opacity: 0.8; margin-bottom: 4px;">SCRIPT SUGERAT:</div>
          <div style="font-size: 13px; line-height: 1.4;">${script.text}</div>
        </div>
        <div style="display: flex; gap: 8px; margin-top: 12px;">
          <button onclick="useScript('${script.text}')" 
                  style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 11px;">
            ✓ FOLOSESTE
          </button>
          <button onclick="generateAlternativeScript()" 
                  style="background: rgba(255,255,255,0.1); border: none; color: white; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 11px;">
            🔄 ALTERNATIVA
          </button>
          <button onclick="advanceScriptPhase()" 
                  style="background: rgba(255,255,255,0.1); border: none; color: white; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 11px;">
            ➡️ FAZA URMATOARE
          </button>
        </div>
      `;
      
      // Auto-hide after 15 seconds
      setTimeout(() => {
        if (scriptAlert && scriptAlert.parentNode) {
          scriptAlert.style.animation = 'slideOutDown 0.3s ease-in';
          setTimeout(() => {
            if (scriptAlert.parentNode) {
              scriptAlert.parentNode.removeChild(scriptAlert);
            }
          }, 300);
        }
      }, 15000);
    }
    
    // Global functions for script interaction
    function useScript(scriptText) {
      // Add to conversation tracking
      if (analyticsData.currentSession) {
        analyticsData.currentSession.conversationData.transcript.push({
          text: '[SALES REP] ' + scriptText,
          timestamp: Date.now(),
          analysis: { scriptUsed: true, phase: currentScriptPhase }
        });
      }
      
      // Update transcript display
      const transcriptElement = document.getElementById('transcript');
      if (transcriptElement) {
        const scriptEntry = document.createElement('div');
        scriptEntry.style.cssText = 'color: var(--success); margin-bottom: 4px; font-weight: bold; padding: 8px; background: rgba(34, 197, 94, 0.1); border-radius: 6px;';
        scriptEntry.innerHTML = `[SCRIPT FOLOSIT] ${scriptText}`;
        transcriptElement.insertBefore(scriptEntry, transcriptElement.firstChild);
      }
      
      // Hide script suggestion
      const scriptAlert = document.getElementById('scriptSuggestion');
      if (scriptAlert) {
        scriptAlert.style.display = 'none';
      }
      
      console.log('Script used:', scriptText);
    }
    
    function generateAlternativeScript() {
      const newScript = generatePersonalizedScript(currentScriptPhase);
      if (newScript) {
        showScriptSuggestion(newScript);
      }
    }
    
    function advanceScriptPhase() {
      const phases = ['opening', 'discovery', 'presentation', 'closing'];
      const currentIndex = phases.indexOf(currentScriptPhase);
      const nextIndex = (currentIndex + 1) % phases.length;
      updateScriptPhase(phases[nextIndex]);
    }
    
    // Auto-generate scripts based on conversation progress
    function autoGenerateScripts() {
      if (!analyticsData.currentSession) return;
      
      const transcriptLength = analyticsData.currentSession.conversationData.transcript.length;
      const conversationDuration = Date.now() - analyticsData.currentSession.startTime;
      
      // Auto-advance phases based on conversation progress
      if (transcriptLength > 2 && currentScriptPhase === 'opening') {
        updateScriptPhase('discovery');
      } else if (transcriptLength > 5 && currentScriptPhase === 'discovery') {
        updateScriptPhase('presentation');
      } else if (transcriptLength > 8 && currentScriptPhase === 'presentation') {
        updateScriptPhase('closing');
      }
      
      // Generate script if none shown recently
      const lastScriptTime = suggestedScripts.length > 0 ? 
        suggestedScripts[suggestedScripts.length - 1].timestamp : 0;
      
      if (Date.now() - lastScriptTime > 30000) { // 30 seconds since last script
        const script = generatePersonalizedScript();
        if (script) {
          script.timestamp = Date.now();
          suggestedScripts.push(script);
          showScriptSuggestion(script);
        }
      }
    }

    // Timing Recommendation Functions
    function analyzeConversationTiming(text) {
      if (!text) return;
      
      const textLower = text.toLowerCase();
      const words = textLower.split(/\s+/);
      
      // Analyze trust building indicators
      const trustPositive = timingIndicators.trustBuilding.positive.filter(word => 
        words.some(w => w.includes(word))
      ).length;
      const trustNegative = timingIndicators.trustBuilding.negative.filter(word => 
        words.some(w => w.includes(word))
      ).length;
      
      // Update trust level (weighted moving average)
      const trustDelta = (trustPositive - trustNegative) * 0.1;
      timingState.trustLevel = Math.max(0, Math.min(1, timingState.trustLevel + trustDelta));
      
      // Analyze engagement momentum
      const engagementHigh = timingIndicators.engagement.high.filter(word => 
        words.some(w => w.includes(word))
      ).length;
      const engagementLow = timingIndicators.engagement.low.filter(word => 
        words.some(w => w.includes(word))
      ).length;
      
      const engagementDelta = (engagementHigh - engagementLow) * 0.15;
      timingState.engagementMomentum = Math.max(0, Math.min(1, timingState.engagementMomentum + engagementDelta));
      
      // Analyze buying signals
      const buyingStrong = timingIndicators.buying_signals.strong.filter(word => 
        words.some(w => w.includes(word))
      ).length;
      const buyingWeak = timingIndicators.buying_signals.weak.filter(word => 
        words.some(w => w.includes(word))
      ).length;
      
      const buyingDelta = (buyingStrong - buyingWeak) * 0.2;
      timingState.buyingSignals = Math.max(0, Math.min(1, timingState.buyingSignals + buyingDelta));
      
      // Analyze urgency level
      const urgencyHigh = timingIndicators.urgency.high.filter(word => 
        words.some(w => w.includes(word))
      ).length;
      const urgencyLow = timingIndicators.urgency.low.filter(word => 
        words.some(w => w.includes(word))
      ).length;
      
      const urgencyDelta = (urgencyHigh - urgencyLow) * 0.1;
      timingState.urgencyLevel = Math.max(0, Math.min(1, timingState.urgencyLevel + urgencyDelta));
      
      // Update conversation flow
      updateConversationFlow();
      
      // Generate timing recommendations
      generateTimingRecommendations();
      
      // Store timing data for analytics
      if (analyticsData.currentSession) {
        analyticsData.currentSession.addTimingData({
          trust: timingState.trustLevel,
          engagement: timingState.engagementMomentum,
          buyingSignals: timingState.buyingSignals,
          urgency: timingState.urgencyLevel,
          timestamp: Date.now()
        });
      }
    }
    
    function updateConversationFlow() {
      const sessionLength = analyticsData.currentSession ? 
        analyticsData.currentSession.conversationData.transcript.length : 0;
      
      // Determine conversation flow based on metrics
      if (timingState.trustLevel > 0.7 && timingState.engagementMomentum > 0.6) {
        timingState.conversationFlow = 'peak';
      } else if (timingState.trustLevel > 0.5 && timingState.engagementMomentum > 0.4) {
        timingState.conversationFlow = 'building';
      } else if (timingState.trustLevel < 0.3 || timingState.engagementMomentum < 0.2) {
        timingState.conversationFlow = 'declining';
      } else {
        timingState.conversationFlow = 'neutral';
      }
      
      console.log('Conversation flow updated:', timingState.conversationFlow, {
        trust: timingState.trustLevel.toFixed(2),
        engagement: timingState.engagementMomentum.toFixed(2),
        buying: timingState.buyingSignals.toFixed(2)
      });
    }
    
    function generateTimingRecommendations() {
      const sessionLength = analyticsData.currentSession ? 
        analyticsData.currentSession.conversationData.transcript.length : 0;
      
      const now = Date.now();
      const timeSinceLastRecommendation = timingState.lastRecommendation ? 
        (now - timingState.lastRecommendation) / 1000 : 60; // seconds
      
      // Don't spam recommendations
      if (timeSinceLastRecommendation < 30) return;
      
      let recommendation = null;
      let priority = 0;
      let action = null;
      
      // Check for pricing timing
      if (shouldPresentPricing()) {
        recommendation = generatePricingRecommendation();
        action = 'pricing';
        priority = 4;
      }
      // Check for closing timing
      else if (shouldAttemptClosing()) {
        recommendation = generateClosingRecommendation();
        action = 'closing';
        priority = 5;
      }
      // Check for trust building
      else if (needsTrustBuilding()) {
        recommendation = generateTrustBuildingRecommendation();
        action = 'trust';
        priority = 3;
      }
      // Check for engagement recovery
      else if (needsEngagementRecovery()) {
        recommendation = generateEngagementRecommendation();
        action = 'engagement';
        priority = 3;
      }
      
      if (recommendation && priority >= 3) {
        showTimingRecommendation(recommendation, action, priority);
        timingState.lastRecommendation = now;
        
        // Store in timing history
        timingState.timingHistory.push({
          action,
          recommendation,
          timestamp: now,
          metrics: { ...timingState }
        });
      }
    }
    
    function shouldPresentPricing() {
      const thresholds = timingThresholds.pricing;
      const sessionLength = analyticsData.currentSession ? 
        analyticsData.currentSession.conversationData.transcript.length : 0;
      
      return (
        timingState.trustLevel >= thresholds.minTrust &&
        timingState.engagementMomentum >= thresholds.minEngagement &&
        sessionLength >= thresholds.minConversationLength &&
        timingState.conversationFlow === 'peak' &&
        !timingState.timingHistory.some(h => h.action === 'pricing' && (Date.now() - h.timestamp) < 120000) // Not in last 2 minutes
      );
    }
    
    function shouldAttemptClosing() {
      const thresholds = timingThresholds.closing;
      const sessionLength = analyticsData.currentSession ? 
        analyticsData.currentSession.conversationData.transcript.length : 0;
      
      return (
        timingState.trustLevel >= thresholds.minTrust &&
        timingState.engagementMomentum >= thresholds.minEngagement &&
        timingState.buyingSignals >= thresholds.minBuyingSignals &&
        sessionLength >= thresholds.minConversationLength &&
        (timingState.conversationFlow === 'peak' || timingState.urgencyLevel > 0.6)
      );
    }
    
    function needsTrustBuilding() {
      return (
        timingState.trustLevel < 0.4 &&
        timingState.conversationFlow !== 'declining'
      );
    }
    
    function needsEngagementRecovery() {
      const sessionLength = analyticsData.currentSession ? 
        analyticsData.currentSession.conversationData.transcript.length : 0;
      
      return (
        timingState.engagementMomentum < 0.3 ||
        (timingState.conversationFlow === 'declining' && sessionLength > 3)
      );
    }
    
    function generatePricingRecommendation() {
      const recommendations = {
        ro: [
          '🕐 MOMENT PERFECT pentru prezentarea preturilor! Clientul arata incredere si interes ridicat.',
          '💰 TIMING EXCELENT! Clientul este angajat - prezinta investitia acum.',
          '⏰ FEREASTRA IDEALA pentru discutia financiara. Increderea este la nivel optim.'
        ],
        en: [
          '🕐 PERFECT TIMING for pricing presentation! Client shows high trust and interest.',
          '💰 EXCELLENT TIMING! Client is engaged - present the investment now.',
          '⏰ IDEAL WINDOW for financial discussion. Trust is at optimal level.'
        ]
      };
      
      const texts = recommendations[currentLang] || recommendations.en;
      return texts[Math.floor(Math.random() * texts.length)];
    }
    
    function generateClosingRecommendation() {
      const recommendations = {
        ro: [
          '🎯 MOMENT DE INCHIDERE! Toate semnalele sunt pozitive - incearca sa inchizi acum.',
          '✅ CLIENTUL ESTE GATA! Semnale puternice de cumparare - propune urmatorul pas.',
          '🚀 TIMING PERFECT pentru inchidere! Angajament si incredere la nivel maxim.'
        ],
        en: [
          '🎯 CLOSING MOMENT! All signals are positive - attempt to close now.',
          '✅ CLIENT IS READY! Strong buying signals - propose next steps.',
          '🚀 PERFECT TIMING for closing! Engagement and trust at maximum level.'
        ]
      };
      
      const texts = recommendations[currentLang] || recommendations.en;
      return texts[Math.floor(Math.random() * texts.length)];
    }
    
    function generateTrustBuildingRecommendation() {
      const recommendations = {
        ro: [
          '🤝 CONSTRUIESTE INCREDEREA! Clientul pare reticent - ofera testimoniale sau garantii.',
          '📋 NIVEL SCAZUT DE INCREDERE - concentreaza-te pe relatia, nu pe produs.',
          '👥 CLIENTUL ARE INDOIELI - adreseaza direct preocuparile sale.'
        ],
        en: [
          '🤝 BUILD TRUST! Client seems hesitant - offer testimonials or guarantees.',
          '📋 LOW TRUST LEVEL - focus on relationship, not product.',
          '👥 CLIENT HAS DOUBTS - address their concerns directly.'
        ]
      };
      
      const texts = recommendations[currentLang] || recommendations.en;
      return texts[Math.floor(Math.random() * texts.length)];
    }
    
    function generateEngagementRecommendation() {
      const recommendations = {
        ro: [
          '⚡ REANIMA CONVERSATIA! Pune o intrebare puternica sau schimba subiectul.',
          '🔄 ENGAGEMENT SCAZUT - incearca o abordare diferita sau o poveste captivanta.',
          '📢 CLIENTUL SE PLICTISESTE - activeaza conversatia cu exemple concrete.'
        ],
        en: [
          '⚡ REVIVE CONVERSATION! Ask a powerful question or change the subject.',
          '🔄 LOW ENGAGEMENT - try a different approach or captivating story.',
          '📢 CLIENT IS BORED - activate conversation with concrete examples.'
        ]
      };
      
      const texts = recommendations[currentLang] || recommendations.en;
      return texts[Math.floor(Math.random() * texts.length)];
    }

    function showTimingRecommendation(recommendation, action, priority) {
      // Create timing alert element if it doesn't exist
      let timingAlert = document.getElementById('timingAlert');
      if (!timingAlert) {
        timingAlert = document.createElement('div');
        timingAlert.id = 'timingAlert';
        timingAlert.style.cssText = `
          position: fixed;
          top: 50%;
          left: 20px;
          transform: translateY(-50%);
          background: linear-gradient(135deg, #7c3aed, #a855f7);
          color: white;
          padding: 16px;
          border-radius: 12px;
          max-width: 350px;
          box-shadow: 0 8px 25px rgba(124, 58, 237, 0.3);
          z-index: 1000;
          border: 1px solid rgba(255, 255, 255, 0.2);
          backdrop-filter: blur(10px);
          animation: slideInLeft 0.3s ease-out;
        `;
        document.body.appendChild(timingAlert);
        
        // Add CSS animation for timing alerts
        if (!document.getElementById('timingStyles')) {
          const style = document.createElement('style');
          style.id = 'timingStyles';
          style.textContent = `
            @keyframes slideInLeft {
              from { transform: translateY(-50%) translateX(-100%); opacity: 0; }
              to { transform: translateY(-50%) translateX(0); opacity: 1; }
            }
            @keyframes slideOutLeft {
              from { transform: translateY(-50%) translateX(0); opacity: 1; }
              to { transform: translateY(-50%) translateX(-100%); opacity: 0; }
            }
          `;
          document.head.appendChild(style);
        }
      }
      
      // Action emojis and names
      const actionConfig = {
        pricing: { emoji: '💰', name: { ro: 'Timing Prețuri', en: 'Pricing Timing' } },
        closing: { emoji: '🎯', name: { ro: 'Moment Închidere', en: 'Closing Moment' } },
        trust: { emoji: '🤝', name: { ro: 'Construire Încredere', en: 'Trust Building' } },
        engagement: { emoji: '⚡', name: { ro: 'Reactivări', en: 'Re-engagement' } }
      };
      
      const config = actionConfig[action] || { emoji: '⏰', name: { ro: 'Timing', en: 'Timing' } };
      const actionName = config.name[currentLang] || config.name.en;
      
      // Priority colors
      const priorityColors = {
        5: 'rgba(239, 68, 68, 0.9)',   // Critical - red
        4: 'rgba(245, 158, 11, 0.9)',  // High - orange
        3: 'rgba(124, 58, 237, 0.9)'   // Medium - purple
      };
      
      timingAlert.style.background = `linear-gradient(135deg, ${priorityColors[priority]}, ${priorityColors[priority].replace('0.9', '0.7')})`;
      
      timingAlert.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-weight: bold; font-size: 14px;">
          <span style="font-size: 18px;">${config.emoji}</span>
          <span style="text-transform: uppercase; letter-spacing: 0.5px;">${actionName}</span>
          <button onclick="this.parentElement.parentElement.style.display='none'" 
                  style="margin-left: auto; background: none; border: none; color: white; font-size: 18px; cursor: pointer; padding: 0;">
            ×
          </button>
        </div>
        <div style="background: rgba(0,0,0,0.2); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
          <div style="font-size: 12px; opacity: 0.8; margin-bottom: 4px;">TIMING RECOMMENDATION:</div>
          <div style="font-size: 13px; line-height: 1.4;">${recommendation}</div>
        </div>
        <div style="background: rgba(0,0,0,0.1); padding: 8px; border-radius: 6px; font-size: 11px;">
          <div style="margin-bottom: 4px;">METRICS:</div>
          <div>Trust: ${(timingState.trustLevel * 100).toFixed(0)}% | Engagement: ${(timingState.engagementMomentum * 100).toFixed(0)}%</div>
          <div>Buying Signals: ${(timingState.buyingSignals * 100).toFixed(0)}% | Flow: ${timingState.conversationFlow.toUpperCase()}</div>
        </div>
      `;
      
      // Auto-hide after 10 seconds
      setTimeout(() => {
        if (timingAlert && timingAlert.parentNode) {
          timingAlert.style.animation = 'slideOutLeft 0.3s ease-in';
          setTimeout(() => {
            if (timingAlert.parentNode) {
              timingAlert.parentNode.removeChild(timingAlert);
            }
          }, 300);
        }
      }, 10000);
    }

    // Client Interest Warning System Functions
    function analyzeClientInterestLoss(text, microExpressions, voiceStress, engagement) {
      if (!text && !microExpressions) return;
      
      let riskFactors = [];
      let riskScore = 0;
      
      // Analyze verbal disengagement
      if (text) {
        const verbalRisk = analyzeVerbalDisengagement(text);
        riskFactors.push(...verbalRisk.factors);
        riskScore += verbalRisk.score;
      }
      
      // Analyze physiological indicators
      if (microExpressions && voiceStress && engagement) {
        const physioRisk = analyzePhysiologicalDisengagement(microExpressions, voiceStress, engagement);
        riskFactors.push(...physioRisk.factors);
        riskScore += physioRisk.score;
      }
      
      // Update engagement trend
      updateEngagementTrend(riskScore);
      
      // Calculate final risk level
      const finalRiskLevel = Math.min(1.0, riskScore / 3); // Normalize to 0-1
      interestWarningState.riskLevel = finalRiskLevel;
      
      // Check for warning triggers
      checkWarningTriggers(finalRiskLevel, riskFactors);
      
      // Store warning data for analytics
      if (analyticsData.currentSession) {
        analyticsData.currentSession.addWarningData({
          riskLevel: finalRiskLevel,
          factors: riskFactors,
          timestamp: Date.now()
        });
      }
    }
    
    function analyzeVerbalDisengagement(text) {
      const textLower = text.toLowerCase();
      const words = textLower.split(/\s+/);
      let score = 0;
      let factors = [];
      
      // Check for disengagement verbal cues
      const disengagementCount = warningIndicators.disengagement.verbal.filter(cue => 
        words.some(word => word.includes(cue))
      ).length;
      
      if (disengagementCount > 0) {
        score += disengagementCount * 0.3;
        factors.push(`Verbal disengagement detected (${disengagementCount} cues)`);
      }
      
      // Check for negative sentiment
      Object.keys(warningIndicators.negativeSentiment).forEach(category => {
        const negativeCount = warningIndicators.negativeSentiment[category].filter(word => 
          textLower.includes(word)
        ).length;
        
        if (negativeCount > 0) {
          score += negativeCount * 0.4;
          factors.push(`${category} detected (${negativeCount} indicators)`);
        }
      });
      
      // Check response length (very short responses indicate disengagement)
      if (words.length <= 2 && words.length > 0) {
        score += 0.3;
        factors.push('Very short responses');
        interestWarningState.consecutiveNegativeSignals++;
      } else {
        interestWarningState.consecutiveNegativeSignals = Math.max(0, interestWarningState.consecutiveNegativeSignals - 1);
      }
      
      return { score, factors };
    }
    
    function analyzePhysiologicalDisengagement(microExpressions, voiceStress, engagement) {
      let score = 0;
      let factors = [];
      
      // Check engagement levels
      if (engagement.overallEngagement < warningIndicators.physiological.lowEngagement) {
        score += 0.5;
        factors.push(`Low engagement detected (${(engagement.overallEngagement * 100).toFixed(0)}%)`);
      }
      
      // Check stress levels
      if (voiceStress.stress > warningIndicators.physiological.highStress) {
        score += 0.4;
        factors.push(`High stress in voice (${(voiceStress.stress * 100).toFixed(0)}%)`);
      }
      
      // Check confidence levels
      if (voiceStress.confidence < warningIndicators.physiological.lowConfidence) {
        score += 0.3;
        factors.push(`Low confidence detected (${(voiceStress.confidence * 100).toFixed(0)}%)`);
      }
      
      // Check micro-expressions for negative indicators
      if (microExpressions.doubt > 0.6) {
        score += 0.4;
        factors.push(`High doubt detected (${(microExpressions.doubt * 100).toFixed(0)}%)`);
      }
      
      if (microExpressions.confusion > 0.5) {
        score += 0.3;
        factors.push(`Confusion detected (${(microExpressions.confusion * 100).toFixed(0)}%)`);
      }
      
      return { score, factors };
    }
    
    function updateEngagementTrend(riskScore) {
      const now = Date.now();
      interestWarningState.engagementTrend.push({
        timestamp: now,
        risk: riskScore,
        health: 1 - riskScore
      });
      
      // Keep only last 10 data points (sliding window)
      if (interestWarningState.engagementTrend.length > 10) {
        interestWarningState.engagementTrend = interestWarningState.engagementTrend.slice(-10);
      }
      
      // Calculate conversation health trend
      if (interestWarningState.engagementTrend.length >= 3) {
        const recent = interestWarningState.engagementTrend.slice(-3);
        const avgHealth = recent.reduce((sum, point) => sum + point.health, 0) / recent.length;
        interestWarningState.conversationHealth = avgHealth;
      }
    }
    
    function checkWarningTriggers(riskLevel, factors) {
      const now = Date.now();
      const timeSinceLastWarning = interestWarningState.lastWarning ? 
        (now - interestWarningState.lastWarning) / 1000 : 60;
      
      // Don't spam warnings
      if (timeSinceLastWarning < 20) return;
      
      let warningLevel = null;
      
      // Determine warning level
      if (riskLevel >= warningLevels.RED.threshold) {
        warningLevel = 'RED';
      } else if (riskLevel >= warningLevels.ORANGE.threshold) {
        warningLevel = 'ORANGE';
      } else if (riskLevel >= warningLevels.YELLOW.threshold) {
        warningLevel = 'YELLOW';
      }
      
      // Additional triggers based on patterns
      if (interestWarningState.consecutiveNegativeSignals >= 3) {
        warningLevel = warningLevel || 'ORANGE';
        factors.push('Multiple consecutive negative signals');
      }
      
      if (interestWarningState.conversationHealth < 0.3) {
        warningLevel = 'RED';
        factors.push('Conversation health critically low');
      }
      
      if (warningLevel) {
        const warning = generateInterestWarning(warningLevel, riskLevel, factors);
        showInterestWarning(warning);
        
        // Update warning state
        interestWarningState.lastWarning = now;
        interestWarningState.warningHistory.push({
          level: warningLevel,
          risk: riskLevel,
          factors: [...factors],
          timestamp: now
        });
        
        console.log(`Interest warning triggered: ${warningLevel} (${(riskLevel * 100).toFixed(1)}% risk)`, factors);
      }
    }
    
    function generateInterestWarning(level, riskLevel, factors) {
      const config = warningLevels[level];
      
      const warnings = {
        YELLOW: {
          ro: [
            '⚠️ ATENTIE! Clientul pare mai putin angajat. Pune o intrebare deschisa.',
            '🟡 ENGAGEMENT SCAZUT! Incearca sa reactivezi conversatia.',
            '⚡ CLIENTUL SE DETASEAZA! Schimba subiectul sau ofera un exemplu concret.'
          ],
          en: [
            '⚠️ ATTENTION! Client seems less engaged. Ask an open question.',
            '🟡 LOW ENGAGEMENT! Try to reactivate the conversation.',
            '⚡ CLIENT DETACHING! Change subject or offer concrete example.'
          ]
        },
        ORANGE: {
          ro: [
            '🔶 RISC MODERAT! Clientul pierde interesul. Concentreaza-te pe valoare si beneficii.',
            '⚠️ ATENTIE SPORITA! Conversatia se deterioreaza. Incearca o abordare diferita.',
            '🚨 RISC DE PIERDERE! Adreseaza direct preocuparile clientului.'
          ],
          en: [
            '🔶 MODERATE RISK! Client is losing interest. Focus on value and benefits.',
            '⚠️ INCREASED ATTENTION! Conversation deteriorating. Try different approach.',
            '🚨 LOSS RISK! Address client concerns directly.'
          ]
        },
        RED: {
          ro: [
            '🚨 ALERTA CRITICA! Clientul vrea sa plece! Actiune de urgenta necesara!',
            '🔴 RISC MAXIM! Conversatia esueaza! Ofera pauza sau reprogrameaza!',
            '💥 SITUATIE DE URGENTA! Clientul s-a dezangajat complet! Actiune imediata!'
          ],
          en: [
            '🚨 CRITICAL ALERT! Client wants to leave! Emergency action needed!',
            '🔴 MAXIMUM RISK! Conversation failing! Offer break or reschedule!',
            '💥 EMERGENCY! Client completely disengaged! Immediate action!'
          ]
        }
      };
      
      const messages = warnings[level][currentLang] || warnings[level].en;
      const message = messages[Math.floor(Math.random() * messages.length)];
      
      return {
        level,
        message,
        riskLevel,
        factors,
        actions: config.actions,
        priority: config.priority,
        color: config.color
      };
    }
    
    function showInterestWarning(warning) {
      // Create warning alert element if it doesn't exist
      let warningAlert = document.getElementById('interestWarning');
      if (!warningAlert) {
        warningAlert = document.createElement('div');
        warningAlert.id = 'interestWarning';
        document.body.appendChild(warningAlert);
        
        // Add CSS animation for warnings
        if (!document.getElementById('warningStyles')) {
          const style = document.createElement('style');
          style.id = 'warningStyles';
          style.textContent = `
            @keyframes warningPulse {
              0% { transform: scale(1); box-shadow: 0 0 20px rgba(220, 38, 38, 0.5); }
              50% { transform: scale(1.05); box-shadow: 0 0 30px rgba(220, 38, 38, 0.8); }
              100% { transform: scale(1); box-shadow: 0 0 20px rgba(220, 38, 38, 0.5); }
            }
            @keyframes warningSlideIn {
              from { transform: translateY(-100%) scale(0.8); opacity: 0; }
              to { transform: translateY(0) scale(1); opacity: 1; }
            }
            @keyframes warningSlideOut {
              from { transform: translateY(0) scale(1); opacity: 1; }
              to { transform: translateY(-100%) scale(0.8); opacity: 0; }
            }
          `;
          document.head.appendChild(style);
        }
      }
      
      // Position and style based on warning level
      const isUrgent = warning.level === 'RED';
      
      warningAlert.style.cssText = `
        position: fixed;
        top: ${isUrgent ? '50%' : '80px'};
        left: 50%;
        transform: translate(-50%, ${isUrgent ? '-50%' : '0'});
        background: linear-gradient(135deg, ${warning.color}, ${warning.color}dd);
        color: white;
        padding: ${isUrgent ? '24px' : '16px'};
        border-radius: ${isUrgent ? '16px' : '12px'};
        max-width: ${isUrgent ? '500px' : '400px'};
        min-width: 350px;
        box-shadow: 0 ${isUrgent ? '12px 40px' : '8px 25px'} ${warning.color}40;
        z-index: ${isUrgent ? '9999' : '1000'};
        border: 2px solid rgba(255, 255, 255, 0.3);
        backdrop-filter: blur(15px);
        animation: ${isUrgent ? 'warningPulse 1s infinite, warningSlideIn 0.4s ease-out' : 'warningSlideIn 0.3s ease-out'};
        text-align: center;
      `;
      
      // Level indicators
      const levelEmojis = {
        YELLOW: '⚠️',
        ORANGE: '🔶',
        RED: '🚨'
      };
      
      const levelNames = {
        ro: {
          YELLOW: 'ATENTIE',
          ORANGE: 'RISC MODERAT',
          RED: 'ALERTA CRITICA'
        },
        en: {
          YELLOW: 'ATTENTION',
          ORANGE: 'MODERATE RISK',
          RED: 'CRITICAL ALERT'
        }
      };
      
      const levelName = levelNames[currentLang][warning.level] || warning.level;
      const emoji = levelEmojis[warning.level];
      
      warningAlert.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 12px; font-weight: bold; font-size: ${isUrgent ? '18px' : '16px'};">
          <span style="font-size: ${isUrgent ? '24px' : '20px'}; animation: ${isUrgent ? 'warningPulse 1s infinite' : 'none'};">${emoji}</span>
          <span style="text-transform: uppercase; letter-spacing: 1px;">${levelName}</span>
          <span style="font-size: ${isUrgent ? '24px' : '20px'}; animation: ${isUrgent ? 'warningPulse 1s infinite' : 'none'};">${emoji}</span>
        </div>
        <div style="background: rgba(0,0,0,0.3); padding: ${isUrgent ? '16px' : '12px'}; border-radius: 10px; margin-bottom: 12px; box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);">
          <div style="font-size: ${isUrgent ? '16px' : '14px'}; line-height: 1.5; font-weight: bold;">${warning.message}</div>
        </div>
        <div style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-bottom: 12px;">
          <div style="font-size: 11px; opacity: 0.9; margin-bottom: 6px; font-weight: bold;">RISK LEVEL: ${(warning.riskLevel * 100).toFixed(0)}%</div>
          <div style="background: rgba(0,0,0,0.3); border-radius: 6px; height: 6px; overflow: hidden;">
            <div style="background: white; height: 100%; width: ${(warning.riskLevel * 100).toFixed(0)}%; transition: width 0.3s ease;"></div>
          </div>
        </div>
        ${warning.factors.length > 0 ? `
        <div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; margin-bottom: 12px;">
          <div style="font-size: 10px; opacity: 0.8; margin-bottom: 4px;">WARNING FACTORS:</div>
          <div style="font-size: 11px; line-height: 1.3;">• ${warning.factors.slice(0, 3).join('<br>• ')}</div>
        </div>
        ` : ''}
        <div style="display: flex; gap: 8px; justify-content: center;">
          <button onclick="acknowledgeWarning()" 
                  style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 12px; font-weight: bold;">
            ✓ UNDERSTOOD
          </button>
          ${isUrgent ? `
          <button onclick="emergencyAction()" 
                  style="background: rgba(255,255,255,0.9); border: none; color: ${warning.color}; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 12px; font-weight: bold;">
            🚨 EMERGENCY ACTION
          </button>
          ` : ''}
        </div>
      `;
      
      // Auto-hide based on urgency level
      const hideDelay = isUrgent ? 15000 : 8000; // 15s for critical, 8s for others
      setTimeout(() => {
        if (warningAlert && warningAlert.parentNode) {
          warningAlert.style.animation = 'warningSlideOut 0.3s ease-in';
          setTimeout(() => {
            if (warningAlert.parentNode) {
              warningAlert.parentNode.removeChild(warningAlert);
            }
          }, 300);
        }
      }, hideDelay);
    }
    
    // Global functions for warning interaction
    function acknowledgeWarning() {
      const warningAlert = document.getElementById('interestWarning');
      if (warningAlert) {
        warningAlert.style.display = 'none';
      }
      
      // Log acknowledgment
      if (analyticsData.currentSession) {
        analyticsData.currentSession.conversationData.transcript.push({
          text: '[WARNING ACKNOWLEDGED]',
          timestamp: Date.now(),
          analysis: { warningAcknowledged: true }
        });
      }
      
      console.log('Interest warning acknowledged by sales professional');
    }
    
    function emergencyAction() {
      const warningAlert = document.getElementById('interestWarning');
      if (warningAlert) {
        warningAlert.style.display = 'none';
      }
      
      // Show emergency action suggestions
      const emergencyActions = {
        ro: [
          'Opriti prezentarea si intrebati: "Vad ca ceva nu este clar. Ce va preocupa cel mai mult?"',
          'Oferiti o pauza: "Sa facem o pauza scurta. Cand reluam, ce ati vrea sa clarificam?"',
          'Reprogramati: "Simt ca nu este momentul potrivit. Cand ar fi mai bine sa ne revedem?"'
        ],
        en: [
          'Stop presentation and ask: "I see something isn\'t clear. What concerns you most?"',
          'Offer a break: "Let\'s take a short break. When we resume, what would you like to clarify?"',
          'Reschedule: "I sense this isn\'t the right time. When would be better to reconnect?"'
        ]
      };
      
      const actions = emergencyActions[currentLang] || emergencyActions.en;
      const action = actions[Math.floor(Math.random() * actions.length)];
      
      alert(`🚨 EMERGENCY ACTION SUGGESTION:\n\n${action}`);
      
      // Log emergency action
      if (analyticsData.currentSession) {
        analyticsData.currentSession.conversationData.transcript.push({
          text: '[EMERGENCY ACTION TRIGGERED]',
          timestamp: Date.now(),
          analysis: { emergencyAction: true, suggestion: action }
        });
      }
      
      console.log('Emergency action triggered:', action);
    }

    function generateLiveRecommendations() {
      const client = analysisData.clientPotential.score;
      const financial = analysisData.financialPower.score;
      const premium = analysisData.premiumOpenness.score;
      
      // Debug logging to understand why we always get CLIENT PROVOCARE
      console.log('Recommendation scores:', { client, financial, premium });
      
      let recommendation = '';
      let priority = 0;

      // High potential client with strong financial power
      if (client >= 0.7 && financial >= 0.7) {
        if (premium >= 0.7) {
          recommendation = '🎆 CLIENT IDEAL! Propune pachetul premium acum. Subliniază valoarea și exclusivitatea.';
          priority = 5;
        } else if (premium >= 0.4) {
          recommendation = '🔥 CLIENT PUTERNIC! Începe cu pachetul mediu, apoi upgrade la premium. Arată beneficiile concrete.';
          priority = 4;
        } else {
          recommendation = '💰 CLIENT CU POTENȚIAL! Concentrează-te pe valoare și ROI. Evită să pară prea scump.';
          priority = 3;
        }
      }
      // Good potential but limited finances
      else if (client >= 0.7 && financial < 0.4) {
        recommendation = '🟡 CLIENT INTERESAT dar buget limitat. Oferă opțiuni de plată și pachete entry-level.';
        priority = 3;
      }
      // Low interest but good finances
      else if (client < 0.4 && financial >= 0.7) {
        recommendation = '🔄 CLIENT PROVOCARE! Are bani dar nu e convins. Folosește studii de caz și demonstrații.';
        priority = 2;
      }
      // Low scores overall
      else if (client < 0.4 && financial < 0.4) {
        recommendation = '⚠️ ATENȚIE! Scor scăzut. Qualifică mai bine sau consideră încheierea conversației.';
        priority = 1;
      }
      // Moderate potential
      else if (client >= 0.4) {
        recommendation = '🟡 POTENȚIAL MODERAT. Pune întrebări deschise pentru a clarifica nevoia și bugetul.';
        priority = 2;
      }
      // Default case when no clear pattern emerges
      else {
        recommendation = '📊 ANALIZÂND... Continue conversația pentru a obține mai multe informații.';
        priority = 1;
      }

      if (recommendation && priority >= 1) { // Changed from >= 2 to >= 1 to show more recommendations
        els.liveRecommendations.style.display = 'block';
        els.recommendationText.textContent = recommendation;
        
        // Add recommendation to current session
        if (analyticsData.currentSession) {
          analyticsData.currentSession.addRecommendation(recommendation);
        }
        
        // Add visual priority indicator
        const bgColor = priority >= 4 ? 'rgba(34, 197, 94, 0.1)' : priority >= 3 ? 'rgba(245, 158, 11, 0.1)' : 'rgba(239, 68, 68, 0.1)';
        els.liveRecommendations.style.background = bgColor;
      } else {
        els.liveRecommendations.style.display = 'none';
      }
    }

    // Initialize MediaPipe
    async function initModels() {
      try {
        setStatus('loading');
        const filesetResolver = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm"
        );
        faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
          baseOptions: { modelAssetPath: MODEL_URL },
          runningMode: "VIDEO",
          numFaces: 1,
          outputFaceBlendshapes: true,
          outputFacialTransformationMatrixes: false
        });
        setStatus('ready');
        els.startBtn.disabled = false;
        els.toggleSpeech.disabled = false;
      } catch (error) {
        console.error('Model initialization failed:', error);
        showError('Eroare la încărcarea modelului MediaPipe');
        setStatus('error');
      }
    }

    // Initialize media
    async function initMedia() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ 
          video: { width: 1280, height: 720 }, 
          audio: true 
        });
        els.video.srcObject = stream;
        await els.video.play();

        // Audio context
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioCtx.createMediaStreamSource(stream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        source.connect(analyser);
        audioData = new Uint8Array(analyser.fftSize);
        
        // Initialize speech recognition
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
          const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
          recognition = new SpeechRecognition();
          recognition.continuous = true;
          recognition.interimResults = true;
          recognition.lang = currentLang === 'ro' ? 'ro-RO' : 'en-US';
          
          recognition.onresult = function(event) {
            let transcript = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
              transcript += event.results[i][0].transcript;
            }
            els.transcript.innerHTML = '<div style="color:var(--text);margin-bottom:4px">' + transcript + '</div>' + els.transcript.innerHTML;
            
            // Analyze the transcript for sales insights
            analyzeKeywords(transcript);
            
            // Keep only last 5 transcript entries
            const transcriptDivs = els.transcript.querySelectorAll('div');
            if (transcriptDivs.length > 5) {
              for (let i = 5; i < transcriptDivs.length; i++) {
                transcriptDivs[i].remove();
              }
            }
          };
          
          recognition.onerror = function(event) {
            console.error('Speech recognition error:', event.error);
            els.speechStatus.textContent = 'Eroare';
          };
        }
        
      } catch (error) {
        console.error('Media initialization failed:', error);
        showError('Eroare la accesarea camerei/microfonului');
      }
    }

    function computeRMS() {
      analyser.getByteTimeDomainData(audioData);
      let sumSq = 0;
      for (let i = 0; i < audioData.length; i++) {
        const v = (audioData[i] - 128) / 128;
        sumSq += v * v;
      }
      const rms = Math.sqrt(sumSq / audioData.length);
      return clamp01((rms - 0.02) / 0.18);
    }

    // Advanced voice stress analysis for sales insights
    function analyzeVoiceStress(audioData) {
      // Get frequency domain data for spectral analysis
      const frequencyData = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(frequencyData);
      
      // Calculate various voice stress indicators
      const voiceMetrics = {
        energy: computeRMS(),
        spectralCentroid: calculateSpectralCentroid(frequencyData),
        zeroCrossingRate: calculateZeroCrossingRate(audioData),
        spectralRolloff: calculateSpectralRolloff(frequencyData),
        jitter: calculateJitter(audioData),
        pauses: detectPauses(audioData)
      };
      
      // Analyze stress indicators based on voice characteristics
      const stressAnalysis = {
        hesitation: analyzeHesitation(voiceMetrics),
        confidence: analyzeConfidence(voiceMetrics),
        stress: analyzeStress(voiceMetrics),
        engagement: analyzeVocalEngagement(voiceMetrics),
        clarity: analyzeClarity(voiceMetrics)
      };
      
      return stressAnalysis;
    }
    
    function calculateSpectralCentroid(frequencyData) {
      let numerator = 0;
      let denominator = 0;
      
      for (let i = 0; i < frequencyData.length; i++) {
        const frequency = (i * 22050) / frequencyData.length; // Assuming 44.1kHz sample rate
        const magnitude = frequencyData[i];
        numerator += frequency * magnitude;
        denominator += magnitude;
      }
      
      return denominator > 0 ? numerator / denominator : 0;
    }
    
    function calculateZeroCrossingRate(audioData) {
      let crossings = 0;
      for (let i = 1; i < audioData.length; i++) {
        const prev = (audioData[i-1] - 128) / 128;
        const curr = (audioData[i] - 128) / 128;
        if (prev * curr < 0) crossings++;
      }
      return crossings / audioData.length;
    }
    
    function calculateSpectralRolloff(frequencyData) {
      const totalEnergy = frequencyData.reduce((sum, val) => sum + val, 0);
      const threshold = totalEnergy * 0.85; // 85% of total energy
      
      let cumulativeEnergy = 0;
      for (let i = 0; i < frequencyData.length; i++) {
        cumulativeEnergy += frequencyData[i];
        if (cumulativeEnergy >= threshold) {
          return (i * 22050) / frequencyData.length;
        }
      }
      return 22050; // Nyquist frequency
    }
    
    function calculateJitter(audioData) {
      // Simplified jitter calculation based on amplitude variations
      let variations = 0;
      for (let i = 2; i < audioData.length; i++) {
        const diff1 = Math.abs(audioData[i] - audioData[i-1]);
        const diff2 = Math.abs(audioData[i-1] - audioData[i-2]);
        variations += Math.abs(diff1 - diff2);
      }
      return variations / (audioData.length - 2);
    }
    
    function detectPauses(audioData) {
      const silenceThreshold = 130; // Close to 128 (silence)
      let silentSamples = 0;
      
      for (let i = 0; i < audioData.length; i++) {
        if (Math.abs(audioData[i] - 128) < 2) {
          silentSamples++;
        }
      }
      
      return silentSamples / audioData.length;
    }
    
    // Voice stress analysis functions
    function analyzeHesitation(metrics) {
      // Hesitation indicators: frequent pauses, low energy, irregular jitter
      const pauseScore = clamp01(metrics.pauses * 3); // More pauses = more hesitation
      const energyScore = clamp01((0.3 - metrics.energy) * 2); // Lower energy = more hesitation
      const jitterScore = clamp01(metrics.jitter / 50); // Higher jitter = more hesitation
      
      return clamp01((pauseScore * 0.4 + energyScore * 0.3 + jitterScore * 0.3));
    }
    
    function analyzeConfidence(metrics) {
      // Confidence indicators: steady energy, clear speech, consistent patterns
      const energyScore = clamp01(metrics.energy * 1.2); // Higher energy = more confidence
      const clarityScore = clamp01((5000 - metrics.spectralCentroid) / 5000); // Lower centroid = clearer speech
      const steadinessScore = clamp01((50 - metrics.jitter) / 50); // Lower jitter = more steady
      
      return clamp01((energyScore * 0.4 + clarityScore * 0.3 + steadinessScore * 0.3));
    }
    
    function analyzeStress(metrics) {
      // Stress indicators: high frequency content, irregular patterns, tension
      const frequencyScore = clamp01((metrics.spectralCentroid - 1000) / 4000); // Higher frequencies = more stress
      const irregularityScore = clamp01(metrics.jitter / 50); // More jitter = more stress
      const tensionScore = clamp01(metrics.zeroCrossingRate * 10); // Higher ZCR = more tension
      
      return clamp01((frequencyScore * 0.4 + irregularityScore * 0.3 + tensionScore * 0.3));
    }
    
    function analyzeVocalEngagement(metrics) {
      // Engagement indicators: dynamic energy, varied patterns, active speech
      const energyScore = clamp01(metrics.energy * 1.5);
      const dynamismScore = clamp01((1 - metrics.pauses) * 1.2); // Less silence = more engagement
      const varietyScore = clamp01(metrics.zeroCrossingRate * 8); // More variation = more engagement
      
      return clamp01((energyScore * 0.4 + dynamismScore * 0.4 + varietyScore * 0.2));
    }
    
    function analyzeClarity(metrics) {
      // Clarity indicators: appropriate frequency range, low jitter, good energy
      const frequencyScore = clamp01((4000 - Math.abs(metrics.spectralCentroid - 2000)) / 4000);
      const stabilityScore = clamp01((50 - metrics.jitter) / 50);
      const presenceScore = clamp01(metrics.energy * 1.1);
      
      return clamp01((frequencyScore * 0.4 + stabilityScore * 0.3 + presenceScore * 0.3));
    }

    function computeSmile(blendshapes) {
      if (!blendshapes || blendshapes.length === 0) return 0;
      const categories = blendshapes[0].categories;
      const get = (name) => {
        const c = categories.find(c => c.categoryName === name);
        return c ? c.score : 0;
      };
      const smile = (get("mouthSmileLeft") + get("mouthSmileRight")) / 2;
      const frown = (get("mouthFrownLeft") + get("mouthFrownRight")) / 2;
      return clamp01(smile - 0.5 * frown);
    }

    // Enhanced micro-expression analysis for sales insights
    function analyzeMicroExpressions(blendshapes) {
      if (!blendshapes || blendshapes.length === 0) {
        return {
          doubt: 0,
          confusion: 0,
          excitement: 0,
          engagement: 0,
          stress: 0,
          confidence: 0,
          interest: 0
        };
      }
      
      const categories = blendshapes[0].categories;
      const get = (name) => {
        const c = categories.find(c => c.categoryName === name);
        return c ? c.score : 0;
      };
      
      // Micro-expression calculations based on MediaPipe Face Landmarker blendshapes
      
      // Doubt indicators (subtle frown, lip compression, brow furrow)
      const doubt = clamp01(
        (get("browDownLeft") + get("browDownRight")) / 2 * 0.4 +
        get("mouthPressLeft") * 0.3 +
        get("mouthPressRight") * 0.3
      );
      
      // Confusion indicators (brow raise, asymmetric expressions, head tilt)
      const confusion = clamp01(
        (get("browInnerUp") + get("browOuterUpLeft") + get("browOuterUpRight")) / 3 * 0.5 +
        Math.abs(get("mouthSmileLeft") - get("mouthSmileRight")) * 0.3 +
        (get("eyeSquintLeft") + get("eyeSquintRight")) / 2 * 0.2
      );
      
      // Excitement indicators (raised eyebrows, wide eyes, genuine smile)
      const excitement = clamp01(
        (get("eyeWideLeft") + get("eyeWideRight")) / 2 * 0.4 +
        (get("mouthSmileLeft") + get("mouthSmileRight")) / 2 * 0.4 +
        (get("browInnerUp") + get("browOuterUpLeft") + get("browOuterUpRight")) / 3 * 0.2
      );
      
      // Engagement indicators (eye contact simulation, forward lean simulation)
      const engagement = clamp01(
        (1 - (get("eyeLookDownLeft") + get("eyeLookDownRight")) / 2) * 0.5 +
        (1 - (get("eyeLookAwayLeft") + get("eyeLookAwayRight")) / 2) * 0.3 +
        (get("eyeWideLeft") + get("eyeWideRight")) / 2 * 0.2
      );
      
      // Stress indicators (jaw tension, eye squinting, mouth press)
      const stress = clamp01(
        get("jawOpen") * 0.2 +
        (get("eyeSquintLeft") + get("eyeSquintRight")) / 2 * 0.4 +
        (get("mouthPressLeft") + get("mouthPressRight")) / 2 * 0.4
      );
      
      // Confidence indicators (relaxed expression, slight smile, open posture)
      const confidence = clamp01(
        (get("mouthSmileLeft") + get("mouthSmileRight")) / 2 * 0.4 +
        (1 - stress) * 0.3 +
        (1 - doubt) * 0.3
      );
      
      // Interest indicators (forward attention, eyebrow flash, mouth slightly open)
      const interest = clamp01(
        engagement * 0.4 +
        (get("browInnerUp") + get("browOuterUpLeft") + get("browOuterUpRight")) / 3 * 0.3 +
        get("mouthFunnel") * 0.3
      );
      
      return {
        doubt: doubt,
        confusion: confusion,
        excitement: excitement,
        engagement: engagement,
        stress: stress,
        confidence: confidence,
        interest: interest
      };
    }

    // Advanced engagement tracking with eye contact detection
    function analyzeEngagement(faceLandmarks, blendshapes) {
      if (!faceLandmarks || faceLandmarks.length === 0) {
        return {
          eyeContact: 0,
          attentionLevel: 0,
          gazeDirection: { x: 0, y: 0 },
          blinkRate: 0,
          headPose: { pitch: 0, yaw: 0, roll: 0 },
          overallEngagement: 0
        };
      }
      
      const landmarks = faceLandmarks[0];
      
      // Calculate eye contact estimation
      const eyeContact = calculateEyeContact(landmarks, blendshapes);
      
      // Calculate attention level based on multiple factors
      const attentionLevel = calculateAttentionLevel(landmarks, blendshapes);
      
      // Estimate gaze direction
      const gazeDirection = estimateGazeDirection(landmarks);
      
      // Calculate blink rate
      const blinkRate = calculateBlinkRate(blendshapes);
      
      // Estimate head pose
      const headPose = estimateHeadPose(landmarks);
      
      // Calculate overall engagement score
      const overallEngagement = calculateOverallEngagement({
        eyeContact,
        attentionLevel,
        gazeDirection,
        blinkRate,
        headPose
      });
      
      return {
        eyeContact,
        attentionLevel,
        gazeDirection,
        blinkRate,
        headPose,
        overallEngagement
      };
    }
    
    function calculateEyeContact(landmarks, blendshapes) {
      if (!blendshapes || blendshapes.length === 0) return 0;
      
      const categories = blendshapes[0].categories;
      const get = (name) => {
        const c = categories.find(c => c.categoryName === name);
        return c ? c.score : 0;
      };
      
      // Eye contact indicators: looking straight, eyes open, not looking away
      const lookingStraight = 1 - (
        (get("eyeLookInLeft") + get("eyeLookInRight") + 
         get("eyeLookOutLeft") + get("eyeLookOutRight") + 
         get("eyeLookUpLeft") + get("eyeLookUpRight") + 
         get("eyeLookDownLeft") + get("eyeLookDownRight")) / 8
      );
      
      const eyesOpen = 1 - ((get("eyeBlinkLeft") + get("eyeBlinkRight")) / 2);
      
      return clamp01((lookingStraight * 0.7 + eyesOpen * 0.3));
    }
    
    function calculateAttentionLevel(landmarks, blendshapes) {
      if (!blendshapes || blendshapes.length === 0) return 0;
      
      const categories = blendshapes[0].categories;
      const get = (name) => {
        const c = categories.find(c => c.categoryName === name);
        return c ? c.score : 0;
      };
      
      // Attention indicators: alert eyes, forward head position, engaged expression
      const alertness = (get("eyeWideLeft") + get("eyeWideRight")) / 2;
      const focus = 1 - ((get("eyeSquintLeft") + get("eyeSquintRight")) / 2);
      const engagement = (get("browInnerUp") + get("browOuterUpLeft") + get("browOuterUpRight")) / 3;
      
      return clamp01((alertness * 0.4 + focus * 0.4 + engagement * 0.2));
    }
    
    function estimateGazeDirection(landmarks) {
      // Simplified gaze estimation using eye landmarks
      const leftEye = {
        inner: landmarks[362], // Left eye inner corner
        outer: landmarks[263], // Left eye outer corner
        center: landmarks[468]  // Left eye center
      };
      
      const rightEye = {
        inner: landmarks[33],   // Right eye inner corner
        outer: landmarks[133],  // Right eye outer corner
        center: landmarks[473]  // Right eye center
      };
      
      // Calculate gaze vector (simplified)
      const gazeX = ((leftEye.center.x + rightEye.center.x) / 2) - 0.5;
      const gazeY = ((leftEye.center.y + rightEye.center.y) / 2) - 0.5;
      
      return { x: gazeX * 2, y: gazeY * 2 }; // Normalize to -1 to 1
    }
    
    let previousBlinkState = { left: 0, right: 0 };
    let blinkCounter = { left: 0, right: 0, timestamp: Date.now() };
    
    function calculateBlinkRate(blendshapes) {
      if (!blendshapes || blendshapes.length === 0) return 0;
      
      const categories = blendshapes[0].categories;
      const get = (name) => {
        const c = categories.find(c => c.categoryName === name);
        return c ? c.score : 0;
      };
      
      const currentBlink = {
        left: get("eyeBlinkLeft"),
        right: get("eyeBlinkRight")
      };
      
      const now = Date.now();
      
      // Detect blink transitions (closed -> open)
      if (previousBlinkState.left > 0.5 && currentBlink.left < 0.3) {
        blinkCounter.left++;
      }
      if (previousBlinkState.right > 0.5 && currentBlink.right < 0.3) {
        blinkCounter.right++;
      }
      
      previousBlinkState = currentBlink;
      
      // Calculate blinks per minute over last 10 seconds
      const timeDiff = now - blinkCounter.timestamp;
      if (timeDiff > 10000) { // Reset every 10 seconds
        const avgBlinks = (blinkCounter.left + blinkCounter.right) / 2;
        const blinksPerMinute = (avgBlinks / timeDiff) * 60000;
        
        blinkCounter = { left: 0, right: 0, timestamp: now };
        
        // Normal blink rate is 15-20 per minute
        // Lower rate might indicate high focus or stress
        // Higher rate might indicate fatigue or discomfort
        return clamp01(Math.abs(17.5 - blinksPerMinute) / 10); // Normalized deviation from normal
      }
      
      return 0;
    }
    
    function estimateHeadPose(landmarks) {
      // Simplified head pose estimation using key facial landmarks
      const noseTip = landmarks[1];
      const leftEye = landmarks[33];
      const rightEye = landmarks[263];
      const leftMouth = landmarks[61];
      const rightMouth = landmarks[291];
      
      // Calculate pitch (up/down)
      const eyeLevel = (leftEye.y + rightEye.y) / 2;
      const mouthLevel = (leftMouth.y + rightMouth.y) / 2;
      const pitch = (mouthLevel - eyeLevel) * 100; // Simplified pitch estimation
      
      // Calculate yaw (left/right)
      const eyeDistance = Math.abs(rightEye.x - leftEye.x);
      const mouthDistance = Math.abs(rightMouth.x - leftMouth.x);
      const yaw = (eyeDistance - mouthDistance) * 100; // Simplified yaw estimation
      
      // Calculate roll (tilt)
      const eyeSlope = (rightEye.y - leftEye.y) / (rightEye.x - leftEye.x);
      const roll = Math.atan(eyeSlope) * (180 / Math.PI); // Convert to degrees
      
      return {
        pitch: clamp01((pitch + 5) / 10), // Normalize to 0-1
        yaw: clamp01((yaw + 5) / 10),     // Normalize to 0-1
        roll: clamp01((roll + 15) / 30)   // Normalize to 0-1
      };
    }
    
    function calculateOverallEngagement(metrics) {
      // Combine all engagement metrics into overall score
      const eyeContactWeight = 0.35;
      const attentionWeight = 0.25;
      const gazeStabilityWeight = 0.20;
      const blinkNormalityWeight = 0.10;
      const headPoseWeight = 0.10;
      
      // Calculate gaze stability (how centered the gaze is)
      const gazeStability = 1 - Math.sqrt(metrics.gazeDirection.x * metrics.gazeDirection.x + 
                                          metrics.gazeDirection.y * metrics.gazeDirection.y) / Math.sqrt(2);
      
      // Calculate head pose stability (how straight the head is)
      const headStability = 1 - ((Math.abs(metrics.headPose.pitch - 0.5) + 
                                  Math.abs(metrics.headPose.yaw - 0.5) + 
                                  Math.abs(metrics.headPose.roll - 0.5)) / 3);
      
      // Blink rate normality (closer to normal is better)
      const blinkNormality = 1 - metrics.blinkRate;
      
      const overallScore = (
        metrics.eyeContact * eyeContactWeight +
        metrics.attentionLevel * attentionWeight +
        gazeStability * gazeStabilityWeight +
        blinkNormality * blinkNormalityWeight +
        headStability * headPoseWeight
      );
      
      return clamp01(overallScore);
    }

    // Advanced gesture recognition and body language analysis
    function analyzeGestures(faceLandmarks) {
      if (!faceLandmarks || faceLandmarks.length === 0) {
        return {
          handMovement: 0,
          bodyPosture: 'neutral',
          gestureType: 'none',
          nervousness: 0,
          openness: 0,
          defensiveness: 0,
          confidence: 0,
          interest: 0
        };
      }
      
      const landmarks = faceLandmarks[0];
      
      // Estimate body language from facial positioning and movements
      const bodyLanguage = analyzeBodyLanguageFromFace(landmarks);
      
      // Detect gesture patterns from face movement
      const gesturePatterns = detectGesturePatterns(landmarks);
      
      // Analyze behavioral indicators
      const behavioralIndicators = analyzeBehavioralIndicators(landmarks);
      
      return {
        handMovement: gesturePatterns.handMovement,
        bodyPosture: bodyLanguage.posture,
        gestureType: gesturePatterns.type,
        nervousness: behavioralIndicators.nervousness,
        openness: behavioralIndicators.openness,
        defensiveness: behavioralIndicators.defensiveness,
        confidence: behavioralIndicators.confidence,
        interest: behavioralIndicators.interest
      };
    }
    
    // Store previous landmarks for movement analysis
    let previousLandmarks = null;
    let movementHistory = [];
    
    function analyzeBodyLanguageFromFace(landmarks) {
      // Analyze head position and orientation for body posture clues
      const headCenter = {
        x: (landmarks[10].x + landmarks[151].x) / 2, // Nose tip and chin average
        y: (landmarks[10].y + landmarks[151].y) / 2
      };
      
      // Determine posture based on head position
      let posture = 'neutral';
      
      if (headCenter.y < 0.4) {
        posture = 'leaning_back'; // Head up - possible disinterest or skepticism
      } else if (headCenter.y > 0.6) {
        posture = 'leaning_forward'; // Head down - possible interest or submission
      } else if (headCenter.x < 0.4) {
        posture = 'turned_away'; // Head to side - possible avoidance
      } else if (headCenter.x > 0.6) {
        posture = 'turned_away'; // Head to side - possible avoidance
      } else {
        posture = 'engaged'; // Centered position - good engagement
      }
      
      return { posture, headCenter };
    }
    
    function detectGesturePatterns(landmarks) {
      // Track face movement patterns to infer hand and body gestures
      const currentCenter = {
        x: landmarks[1].x, // Nose tip
        y: landmarks[1].y
      };
      
      let handMovement = 0;
      let gestureType = 'none';
      
      if (previousLandmarks) {
        const prevCenter = {
          x: previousLandmarks[1].x,
          y: previousLandmarks[1].y
        };
        
        // Calculate movement magnitude
        const movement = Math.sqrt(
          Math.pow(currentCenter.x - prevCenter.x, 2) + 
          Math.pow(currentCenter.y - prevCenter.y, 2)
        );
        
        handMovement = Math.min(movement * 100, 1); // Normalize to 0-1
        
        // Add to movement history
        movementHistory.push(movement);
        if (movementHistory.length > 30) { // Keep last 30 frames (~1 second at 30fps)
          movementHistory.shift();
        }
        
        // Analyze movement patterns
        if (movementHistory.length >= 10) {
          const avgMovement = movementHistory.reduce((a, b) => a + b, 0) / movementHistory.length;
          const movementVariation = Math.sqrt(
            movementHistory.reduce((sum, val) => sum + Math.pow(val - avgMovement, 2), 0) / movementHistory.length
          );
          
          // Classify gesture types based on movement patterns
          if (avgMovement > 0.02 && movementVariation > 0.01) {
            gestureType = 'fidgeting'; // High variation = nervous fidgeting
          } else if (avgMovement > 0.015) {
            gestureType = 'animated'; // Consistent movement = animated talking
          } else if (avgMovement < 0.005) {
            gestureType = 'static'; // Very little movement = possible tension
          } else {
            gestureType = 'controlled'; // Moderate movement = controlled gestures
          }
        }
      }
      
      previousLandmarks = landmarks;
      
      return { handMovement, type: gestureType };
    }
    
    function analyzeBehavioralIndicators(landmarks) {
      // Analyze various behavioral cues from facial landmarks
      
      // Nervousness indicators: rapid movements, tense expression
      const mouthWidth = Math.abs(landmarks[61].x - landmarks[291].x);
      const eyeDistance = Math.abs(landmarks[33].x - landmarks[263].x);
      const jawPosition = landmarks[17].y; // Chin position
      
      // Calculate nervousness based on facial tension
      const facialTension = Math.abs(mouthWidth - 0.05) + Math.abs(eyeDistance - 0.1);
      const nervousness = clamp01(facialTension * 10);
      
      // Openness indicators: relaxed face, open eyes, slight smile
      const eyeOpenness = 1 - ((landmarks[145].y - landmarks[159].y) + (landmarks[374].y - landmarks[386].y)) / 2;
      const mouthRelaxation = 1 - Math.abs(landmarks[13].y - landmarks[14].y);
      const openness = clamp01((eyeOpenness + mouthRelaxation) / 2);
      
      // Defensiveness indicators: closed posture cues from face position
      const headTilt = Math.abs(landmarks[33].y - landmarks[263].y); // Eye level difference
      const mouthTightness = Math.abs(landmarks[61].y - landmarks[291].y);
      const defensiveness = clamp01((headTilt + mouthTightness) * 5);
      
      // Confidence indicators: steady posture, direct gaze simulation
      const posturalStability = 1 - nervousness;
      const gazeDirectness = 1 - defensiveness;
      const confidence = clamp01((posturalStability + gazeDirectness) / 2);
      
      // Interest indicators: forward lean simulation, alert expression
      const forwardLean = Math.max(0, 0.5 - landmarks[1].y); // Nose position relative to center
      const alertness = eyeOpenness;
      const interest = clamp01((forwardLean * 2 + alertness) / 2);
      
      return {
        nervousness,
        openness,
        defensiveness,
        confidence,
        interest
      };
    }

    function fuseMood(smile, energy) {
      const score = clamp01(0.7 * smile + 0.3 * energy);
      let state = "neutral";
      if (score >= 0.6) state = "good";
      else if (score <= 0.4) state = "bad";
      return { score, state };
    }

    // Micro-expressions helper functions
    function updateMicroExpressionsDisplay(microExpressions) {
      const formatLevel = (value) => {
        const percentage = Math.round(value * 100);
        const color = value > 0.7 ? 'var(--danger)' : 
                     value > 0.4 ? 'var(--warning)' : 
                     value > 0.2 ? 'var(--text)' : 'var(--muted)';
        return { text: `${percentage}%`, color };
      };
      
      const doubt = formatLevel(microExpressions.doubt);
      const confusion = formatLevel(microExpressions.confusion);
      const excitement = formatLevel(microExpressions.excitement);
      const engagement = formatLevel(microExpressions.engagement);
      const stress = formatLevel(microExpressions.stress);
      const confidence = formatLevel(microExpressions.confidence);
      
      els.doubtLevel.textContent = doubt.text;
      els.doubtLevel.style.color = doubt.color;
      
      els.confusionLevel.textContent = confusion.text;
      els.confusionLevel.style.color = confusion.color;
      
      els.excitementLevel.textContent = excitement.text;
      els.excitementLevel.style.color = excitement.color;
      
      els.engagementLevel.textContent = engagement.text;
      els.engagementLevel.style.color = engagement.color;
      
      els.stressLevel.textContent = stress.text;
      els.stressLevel.style.color = stress.color;
      
      els.confidenceLevel.textContent = confidence.text;
      els.confidenceLevel.style.color = confidence.color;
    }

    function getDominantEmotion(microExpressions) {
      const emotions = {
        doubt: microExpressions.doubt,
        confusion: microExpressions.confusion,
        excitement: microExpressions.excitement,
        engagement: microExpressions.engagement,
        stress: microExpressions.stress,
        confidence: microExpressions.confidence
      };
      
      let maxEmotion = 'neutral';
      let maxValue = 0.3; // Threshold for detecting significant emotion
      
      for (const [emotion, value] of Object.entries(emotions)) {
        if (value > maxValue) {
          maxValue = value;
          maxEmotion = emotion;
        }
      }
      
      return maxEmotion;
    }

    // Voice stress display function
    function updateVoiceStressDisplay(voiceStress) {
      const formatLevel = (value) => {
        const percentage = Math.round(value * 100);
        const color = value > 0.7 ? 'var(--danger)' : 
                     value > 0.4 ? 'var(--warning)' : 
                     value > 0.2 ? 'var(--success)' : 'var(--muted)';
        return { text: `${percentage}%`, color };
      };
      
      const hesitation = formatLevel(voiceStress.hesitation);
      const confidence = formatLevel(voiceStress.confidence);
      const stress = formatLevel(voiceStress.stress);
      const engagement = formatLevel(voiceStress.engagement);
      const clarity = formatLevel(voiceStress.clarity);
      
      els.voiceHesitation.textContent = hesitation.text;
      els.voiceHesitation.style.color = hesitation.color;
      
      els.voiceConfidence.textContent = confidence.text;
      els.voiceConfidence.style.color = confidence.color;
      
      els.voiceStress.textContent = stress.text;
      els.voiceStress.style.color = stress.color;
      
      els.vocalEngagement.textContent = engagement.text;
      els.vocalEngagement.style.color = engagement.color;
      
      els.voiceClarity.textContent = clarity.text;
      els.voiceClarity.style.color = clarity.color;
    }

    // Combined emotional state analysis
    function getCombinedEmotionalState(microExpressions, voiceStress) {
      // Combine facial and vocal analysis for more accurate emotion detection
      const combinedMetrics = {
        doubt: (microExpressions.doubt + voiceStress.hesitation) / 2,
        confusion: microExpressions.confusion,
        excitement: microExpressions.excitement,
        engagement: (microExpressions.engagement + voiceStress.engagement) / 2,
        stress: (microExpressions.stress + voiceStress.stress) / 2,
        confidence: (microExpressions.confidence + voiceStress.confidence) / 2
      };
      
      let dominantEmotion = 'neutral';
      let maxValue = 0.25; // Lower threshold for combined analysis
      
      for (const [emotion, value] of Object.entries(combinedMetrics)) {
        if (value > maxValue) {
          maxValue = value;
          dominantEmotion = emotion;
        }
      }
      
      return dominantEmotion;
    }

    // Engagement display function
    function updateEngagementDisplay(engagement) {
      const formatLevel = (value) => {
        const percentage = Math.round(value * 100);
        const color = value > 0.7 ? 'var(--success)' : 
                     value > 0.4 ? 'var(--warning)' : 
                     value > 0.2 ? 'var(--text)' : 'var(--muted)';
        return { text: `${percentage}%`, color };
      };
      
      // Update overall engagement
      const overall = formatLevel(engagement.overallEngagement);
      els.overallEngagement.textContent = overall.text;
      els.overallEngagement.style.color = overall.color;
      els.engagementBar.style.width = (engagement.overallEngagement * 100).toFixed(0) + "%";
      
      // Update individual metrics
      const eyeContact = formatLevel(engagement.eyeContact);
      const attention = formatLevel(engagement.attentionLevel);
      const blinkRate = formatLevel(1 - engagement.blinkRate); // Invert for display (normal is good)
      
      // Head pose stability (combined metric)
      const headStability = 1 - ((Math.abs(engagement.headPose.pitch - 0.5) + 
                                  Math.abs(engagement.headPose.yaw - 0.5) + 
                                  Math.abs(engagement.headPose.roll - 0.5)) / 3);
      const headPose = formatLevel(headStability);
      
      els.eyeContactLevel.textContent = eyeContact.text;
      els.eyeContactLevel.style.color = eyeContact.color;
      
      els.attentionLevel.textContent = attention.text;
      els.attentionLevel.style.color = attention.color;
      
      els.blinkRateLevel.textContent = blinkRate.text;
      els.blinkRateLevel.style.color = blinkRate.color;
      
      els.headPoseLevel.textContent = headPose.text;
      els.headPoseLevel.style.color = headPose.color;
    }

    // Gesture display function
    function updateGestureDisplay(gestures) {
      const formatLevel = (value) => {
        const percentage = Math.round(value * 100);
        const color = value > 0.7 ? 'var(--danger)' : 
                     value > 0.4 ? 'var(--warning)' : 
                     value > 0.2 ? 'var(--success)' : 'var(--muted)';
        return { text: `${percentage}%`, color };
      };
      
      // Gesture type translation
      const gestureTranslations = {
        'none': 'Niciunul',
        'fidgeting': 'Agitație',
        'animated': 'Animat',
        'static': 'Static',
        'controlled': 'Controlat'
      };
      
      // Body posture translation
      const postureTranslations = {
        'neutral': 'Neutru',
        'leaning_back': 'Înclinat îenapoi',
        'leaning_forward': 'Înclinat înainte',
        'turned_away': 'Evită privirea',
        'engaged': 'Angajat'
      };
      
      // Update gesture type with appropriate color
      const gestureText = gestureTranslations[gestures.gestureType] || gestures.gestureType;
      const gestureColor = gestures.gestureType === 'fidgeting' ? 'var(--danger)' :
                           gestures.gestureType === 'animated' ? 'var(--success)' :
                           gestures.gestureType === 'controlled' ? 'var(--success)' :
                           gestures.gestureType === 'static' ? 'var(--warning)' : 'var(--muted)';
      
      els.gestureType.textContent = gestureText;
      els.gestureType.style.color = gestureColor;
      
      // Update body posture with appropriate color
      const postureText = postureTranslations[gestures.bodyPosture] || gestures.bodyPosture;
      const postureColor = gestures.bodyPosture === 'engaged' ? 'var(--success)' :
                           gestures.bodyPosture === 'leaning_forward' ? 'var(--success)' :
                           gestures.bodyPosture === 'turned_away' ? 'var(--danger)' :
                           gestures.bodyPosture === 'leaning_back' ? 'var(--warning)' : 'var(--text)';
      
      els.bodyPosture.textContent = postureText;
      els.bodyPosture.style.color = postureColor;
      
      // Update behavioral indicators
      const nervousness = formatLevel(gestures.nervousness);
      const openness = formatLevel(gestures.openness);
      const defensiveness = formatLevel(gestures.defensiveness);
      const interest = formatLevel(gestures.interest);
      
      els.nervousnessLevel.textContent = nervousness.text;
      els.nervousnessLevel.style.color = nervousness.color;
      
      els.opennessLevel.textContent = openness.text;
      els.opennessLevel.style.color = openness.color;
      
      els.defensivenessLevel.textContent = defensiveness.text;
      els.defensivenessLevel.style.color = defensiveness.color;
      
      els.interestLevel.textContent = interest.text;
      els.interestLevel.style.color = interest.color;
    }

    // Main loop
    async function loop() {
      if (!running || paused) return;
      
      const now = performance.now();
      const video = els.video;
      const overlay = els.overlay;
      const ctx = overlay.getContext('2d');

      overlay.width = video.videoWidth;
      overlay.height = video.videoHeight;

      try {
        const res = await faceLandmarker.detectForVideo(video, now);
        const smile = computeSmile(res.faceBlendshapes);
        const microExpressions = analyzeMicroExpressions(res.faceBlendshapes);
        const engagement = analyzeEngagement(res.faceLandmarks, res.faceBlendshapes);
        const gestures = analyzeGestures(res.faceLandmarks);
        const energy = computeRMS();
        const voiceStress = analyzeVoiceStress(audioData);
        const { score, state } = fuseMood(smile, energy);

        // Update basic mood UI
        els.moodBar.style.width = (score * 100).toFixed(0) + "%";
        setLED(state);
        setTip(state);
        
        // Update micro-expressions display
        updateMicroExpressionsDisplay(microExpressions);
        
        // Update voice stress display
        updateVoiceStressDisplay(voiceStress);
        
        // Update engagement tracking display
        updateEngagementDisplay(engagement);
        
        // Update gesture recognition display
        updateGestureDisplay(gestures);
        
        // Update real-time analysis display
        updateAnalysisDisplay();
        
        // Add analysis data to current session
        if (analyticsData.currentSession) {
          analyticsData.currentSession.conversationData.emotionalStates.push({
            timestamp: now,
            mood: { score, state },
            microExpressions: microExpressions,
            voiceStress: voiceStress,
            engagement: engagement,
            gestures: gestures,
            energy: energy
          });
        }
        
        // Draw landmarks
        ctx.clearRect(0, 0, overlay.width, overlay.height);
        if (res.faceLandmarks && res.faceLandmarks.length > 0) {
          const pts = res.faceLandmarks[0];
          
          // Color landmarks based on combined emotion analysis
          const combinedEmotion = getCombinedEmotionalState(microExpressions, voiceStress);
          const colors = {
            doubt: "rgba(239, 68, 68, 0.9)",       // red
            confusion: "rgba(245, 158, 11, 0.9)",  // orange  
            excitement: "rgba(34, 197, 94, 0.9)",  // green
            engagement: "rgba(59, 130, 246, 0.9)", // blue
            stress: "rgba(168, 85, 247, 0.9)",     // purple
            confidence: "rgba(16, 185, 129, 0.9)", // emerald
            neutral: "rgba(156, 163, 175, 0.9)"    // gray
          };
          
          ctx.fillStyle = colors[combinedEmotion] || colors.neutral;
          for (const p of pts) {
            ctx.fillRect(p.x * overlay.width - 1, p.y * overlay.height - 1, 2, 2);
          }
        }

        // FPS calculation
        const dt = (now - lastFrameTs) / 1000;
        lastFrameTs = now;
        els.fps.textContent = (1 / dt).toFixed(1);
        
      } catch (error) {
        console.error('Detection error:', error);
      }

      requestAnimationFrame(loop);
    }

    // Control functions
    function resetAnalysis() {
      analysisData = {
        clientPotential: { score: 0, keywords: [] },
        financialPower: { score: 0, keywords: [] },
        premiumOpenness: { score: 0, keywords: [] },
        conversationLength: 0,
        lastUpdate: Date.now()
      };
      
      // Reset script generation state
      currentScriptPhase = 'opening';
      suggestedScripts = [];
      clientProfileType = null;
      
      // Reset timing state
      timingState = {
        trustLevel: 0,
        engagementMomentum: 0,
        buyingSignals: 0,
        urgencyLevel: 0,
        conversationFlow: 'building',
        lastRecommendation: null,
        timingHistory: []
      };
      
      els.clientPotential.textContent = 'Se analizează...';
      els.clientPotential.style.color = 'var(--muted)';
      els.financialPower.textContent = 'Se analizează...';
      els.financialPower.style.color = 'var(--muted)';
      els.premiumOpenness.textContent = 'Se analizează...';
      els.premiumOpenness.style.color = 'var(--muted)';
      
      els.transcript.innerHTML = '<span class="muted">Transcrierea va apărea aici...</span>';
      els.liveRecommendations.style.display = 'none';
      
      // Hide any active script suggestions
      const scriptAlert = document.getElementById('scriptSuggestion');
      if (scriptAlert) {
        scriptAlert.style.display = 'none';
      }
      
      // Hide any active timing alerts
      const timingAlert = document.getElementById('timingAlert');
      if (timingAlert) {
        timingAlert.style.display = 'none';
      }
    }

    async function start() {
      if (!faceLandmarker) await initModels();
      resetAnalysis();
      
      // Start new analytics session
      analyticsData.currentSession = new SalesSession();
      analyticsData.performanceMetrics.totalSessions++;
      
      els.startBtn.disabled = true;
      els.stopBtn.disabled = false;
      els.pauseBtn.disabled = false;
      setStatus('running');
      running = true;
      paused = false;
      loop();
    }

    function stop() {
      running = false;
      paused = false;
      
      // End current session and save analytics
      if (analyticsData.currentSession) {
        const summary = analyticsData.currentSession.endSession();
        analyticsData.sessions.push(analyticsData.currentSession);
        
        // Update performance metrics
        updatePerformanceMetrics(summary);
        
        // Update or create client profile
        updateClientProfile(analyticsData.currentSession);
        
        // Show session summary (will be enhanced in next task)
        console.log('Session Summary:', summary);
        
        analyticsData.currentSession = null;
      }
      
      setStatus('stopped');
      els.startBtn.disabled = false;
      els.stopBtn.disabled = true;
      els.pauseBtn.disabled = true;
    }

    function pause() {
      paused = !paused;
      els.pauseBtn.textContent = paused ? 'Resume' : 'Pauză';
      setStatus(paused ? 'paused' : 'running');
      if (!paused) loop();
    }

    // Enhanced Analytics functions
    function updatePerformanceMetrics(sessionSummary) {
      const metrics = analyticsData.performanceMetrics;
      const session = analyticsData.sessions[analyticsData.sessions.length - 1];
      
      // Update basic metrics
      const totalDuration = (metrics.avgSessionDuration * (metrics.totalSessions - 1)) + sessionSummary.duration;
      metrics.avgSessionDuration = totalDuration / metrics.totalSessions;
      
      // Enhanced Conversion Tracking
      metrics.conversionMetrics.totalLeads++;
      
      // Calculate lead quality and add to qualified leads if above threshold
      const leadQuality = session.calculateLeadQuality();
      if (leadQuality > 0.5) {
        metrics.conversionMetrics.qualifiedLeads++;
      }
      
      // Update lead quality average
      const totalQuality = (metrics.conversionMetrics.leadQualityScore * (metrics.conversionMetrics.totalLeads - 1)) + leadQuality;
      metrics.conversionMetrics.leadQualityScore = totalQuality / metrics.conversionMetrics.totalLeads;
      
      // Update conversion metrics if deal closed
      if (sessionSummary.outcome.converted) {
        metrics.conversions++;
        metrics.conversionMetrics.closedDeals++;
        
        // Deal Size Analytics
        if (sessionSummary.outcome.dealSize > 0) {
          metrics.dealMetrics.dealSizes.push(sessionSummary.outcome.dealSize);
          metrics.dealMetrics.totalRevenue += sessionSummary.outcome.dealSize;
          
          // Update average deal size
          const totalDeals = (metrics.avgDealSize * (metrics.conversions - 1)) + sessionSummary.outcome.dealSize;
          metrics.avgDealSize = totalDeals / metrics.conversions;
          
          // Track deal cycle
          const dealCycle = session.calculateDealCycle();
          if (dealCycle > 0) {
            const totalCycles = (metrics.dealMetrics.avgDealCycle * (metrics.conversions - 1)) + dealCycle;
            metrics.dealMetrics.avgDealCycle = totalCycles / metrics.conversions;
          }
          
          // Categorize deal size
          const dealCategory = sessionSummary.outcome.dealSize >= 10000 ? 'enterprise' :
                             sessionSummary.outcome.dealSize >= 5000 ? 'large' :
                             sessionSummary.outcome.dealSize >= 1000 ? 'medium' : 'small';
          
          const categoryCount = metrics.dealMetrics.dealsByCategory.get(dealCategory) || 0;
          metrics.dealMetrics.dealsByCategory.set(dealCategory, categoryCount + 1);
          
          // Track monthly revenue
          const currentMonth = new Date().toISOString().slice(0, 7); // YYYY-MM
          const monthlyRevenue = metrics.dealMetrics.revenueByMonth.get(currentMonth) || 0;
          metrics.dealMetrics.revenueByMonth.set(currentMonth, monthlyRevenue + sessionSummary.outcome.dealSize);
        }
      }
      
      // Identify and track success patterns
      const successPatterns = session.identifySuccessPatterns();
      successPatterns.forEach(pattern => {
        if (!metrics.performanceAnalytics.successPatterns.includes(pattern)) {
          metrics.performanceAnalytics.successPatterns.push(pattern);
        }
      });
      
      // Update ROI metrics
      const timeInvested = sessionSummary.duration / (1000 * 60); // minutes
      metrics.performanceAnalytics.roiMetrics.timeInvested += timeInvested;
      
      if (metrics.dealMetrics.totalRevenue > 0 && metrics.performanceAnalytics.roiMetrics.timeInvested > 0) {
        metrics.performanceAnalytics.roiMetrics.revenuePerHour = 
          (metrics.dealMetrics.totalRevenue / metrics.performanceAnalytics.roiMetrics.timeInvested) * 60;
      }
      
      // Update top performing keywords
      if (session && session.conversationData.keywords) {
        session.conversationData.keywords.forEach(keyword => {
          const count = metrics.topKeywords.get(keyword.word) || 0;
          metrics.topKeywords.set(keyword.word, count + 1);
          
          // Track performance of keywords that led to conversions
          if (sessionSummary.outcome.converted) {
            const perfCount = metrics.performanceAnalytics.topPerformingKeywords.get(keyword.word) || 0;
            metrics.performanceAnalytics.topPerformingKeywords.set(keyword.word, perfCount + 1);
          }
        });
      }
      
      // Update conversion trends (daily tracking)
      const today = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
      const existingTrend = metrics.conversionMetrics.conversionTrends.find(t => t.date === today);
      
      if (existingTrend) {
        existingTrend.sessions++;
        if (sessionSummary.outcome.converted) existingTrend.conversions++;
        existingTrend.conversionRate = existingTrend.conversions / existingTrend.sessions;
      } else {
        metrics.conversionMetrics.conversionTrends.push({
          date: today,
          sessions: 1,
          conversions: sessionSummary.outcome.converted ? 1 : 0,
          conversionRate: sessionSummary.outcome.converted ? 1 : 0
        });
      }
      
      // Keep only last 30 days of trends
      if (metrics.conversionMetrics.conversionTrends.length > 30) {
        metrics.conversionMetrics.conversionTrends = metrics.conversionMetrics.conversionTrends.slice(-30);
      }
      
      // Calculate forecasting metrics
      updateForecastingMetrics();
      
      console.log('Enhanced performance metrics updated:', {
        totalLeads: metrics.conversionMetrics.totalLeads,
        qualifiedLeads: metrics.conversionMetrics.qualifiedLeads,
        conversionRate: ((metrics.conversions / metrics.totalSessions) * 100).toFixed(1) + '%',
        avgDealSize: metrics.avgDealSize,
        totalRevenue: metrics.dealMetrics.totalRevenue,
        revenuePerHour: metrics.performanceAnalytics.roiMetrics.revenuePerHour.toFixed(2)
      });
    }

    function updateForecastingMetrics() {
      const metrics = analyticsData.performanceMetrics;
      
      // Calculate pipeline value (current sessions that might convert)
      const activeSessions = metrics.totalSessions - metrics.conversions;
      const conversionRate = metrics.totalSessions > 0 ? metrics.conversions / metrics.totalSessions : 0;
      
      metrics.dealMetrics.forecasting.pipeline = activeSessions * metrics.avgDealSize * conversionRate;
      
      // Project monthly revenue based on current trends
      const currentMonth = new Date().toISOString().slice(0, 7);
      const monthlyRevenue = metrics.dealMetrics.revenueByMonth.get(currentMonth) || 0;
      const daysInMonth = new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0).getDate();
      const currentDay = new Date().getDate();
      
      if (currentDay > 0) {
        metrics.dealMetrics.forecasting.projectedRevenue = (monthlyRevenue / currentDay) * daysInMonth;
      }
      
      // Calculate win probability based on recent trends
      const recentTrends = metrics.conversionMetrics.conversionTrends.slice(-7); // Last 7 days
      if (recentTrends.length > 0) {
        const avgRecentConversion = recentTrends.reduce((sum, trend) => sum + trend.conversionRate, 0) / recentTrends.length;
        metrics.dealMetrics.forecasting.winProbability = avgRecentConversion;
      }
    }

    function generatePerformanceInsights() {
      const metrics = analyticsData.performanceMetrics;
      const insights = [];
      
      // Conversion rate insights
      const conversionRate = metrics.totalSessions > 0 ? metrics.conversions / metrics.totalSessions : 0;
      const benchmarkRate = metrics.performanceAnalytics.benchmarks.industryAvgConversion;
      
      if (conversionRate > benchmarkRate * 1.2) {
        insights.push({
          type: 'success',
          message: translations[currentLang].insights.conversionRateHigh
            .replace('{rate}', (conversionRate * 100).toFixed(1))
            .replace('{percent}', ((conversionRate / benchmarkRate - 1) * 100).toFixed(0)),
          priority: 'high'
        });
      } else if (conversionRate < benchmarkRate * 0.8) {
        insights.push({
          type: 'warning',
          message: `⚠️ ${translations[currentLang].insights.conversionRateLow.replace('{rate}', (conversionRate * 100).toFixed(1))}`,
          priority: 'high'
        });
      }
      
      // Deal size insights
      if (metrics.avgDealSize > metrics.performanceAnalytics.benchmarks.minDealSize * 2) {
        insights.push({
          type: 'success',
          message: `💰 ${translations[currentLang].insights.strongDealSizes.replace('{amount}', metrics.avgDealSize.toFixed(0))}`,
          priority: 'medium'
        });
      }
      
      // Deal cycle insights
      if (metrics.dealMetrics.avgDealCycle > 0 && metrics.dealMetrics.avgDealCycle < metrics.performanceAnalytics.benchmarks.maxDealCycle) {
        insights.push({
          type: 'success',
          message: `⚡ ${translations[currentLang].insights.fastSalesCycle.replace('{days}', metrics.dealMetrics.avgDealCycle)}`,
          priority: 'medium'
        });
      }
      
      // ROI insights
      if (metrics.performanceAnalytics.roiMetrics.revenuePerHour > 500) {
        insights.push({
          type: 'success',
          message: `🚀 ${translations[currentLang].insights.excellentProductivity.replace('{amount}', metrics.performanceAnalytics.roiMetrics.revenuePerHour.toFixed(0))}`,
          priority: 'medium'
        });
      }
      
      // Success pattern insights
      if (metrics.performanceAnalytics.successPatterns.includes('premium_buyer')) {
        insights.push({
          type: 'insight',
          message: `✨ ${translations[currentLang].insights.premiumBuyersDetected}`,
          priority: 'medium'
        });
      }
      
      return insights.sort((a, b) => {
        const priorityOrder = { high: 3, medium: 2, low: 1 };
        return priorityOrder[b.priority] - priorityOrder[a.priority];
      });
    }
    function getAnalyticsSummary() {
      const metrics = analyticsData.performanceMetrics;
      
      // Enhanced analytics summary
      const conversionRate = metrics.totalSessions > 0 ? (metrics.conversions / metrics.totalSessions * 100).toFixed(1) : 0;
      const qualificationRate = metrics.conversionMetrics.totalLeads > 0 ? 
        (metrics.conversionMetrics.qualifiedLeads / metrics.conversionMetrics.totalLeads * 100).toFixed(1) : 0;
      
      return {
        // Basic metrics
        totalSessions: metrics.totalSessions,
        conversionRate: conversionRate,
        avgSessionDuration: Math.round(metrics.avgSessionDuration),
        avgDealSize: metrics.avgDealSize.toFixed(0),
        
        // Enhanced metrics
        totalLeads: metrics.conversionMetrics.totalLeads,
        qualifiedLeads: metrics.conversionMetrics.qualifiedLeads,
        qualificationRate: qualificationRate,
        closedDeals: metrics.conversionMetrics.closedDeals,
        totalRevenue: metrics.dealMetrics.totalRevenue,
        avgDealCycle: Math.round(metrics.dealMetrics.avgDealCycle),
        revenuePerHour: metrics.performanceAnalytics.roiMetrics.revenuePerHour.toFixed(0),
        
        // Forecasting
        pipelineValue: metrics.dealMetrics.forecasting.pipeline.toFixed(0),
        projectedRevenue: metrics.dealMetrics.forecasting.projectedRevenue.toFixed(0),
        winProbability: (metrics.dealMetrics.forecasting.winProbability * 100).toFixed(1),
        
        // Patterns and insights
        successPatterns: metrics.performanceAnalytics.successPatterns,
        topPerformingKeywords: Array.from(metrics.performanceAnalytics.topPerformingKeywords.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5)
          .map(([word, count]) => ({ word, count })),
        
        topKeywords: Array.from(metrics.topKeywords.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 10)
          .map(([word, count]) => ({ word, count })),
          
        dealDistribution: Array.from(metrics.dealMetrics.dealsByCategory.entries())
          .map(([category, count]) => ({ category, count })),
          
        performanceInsights: generatePerformanceInsights()
      };
    }

    // Client Profile Management Functions
    function generateClientId() {
      // Generate a simple client ID based on session patterns
      // In a real implementation, this would be based on actual client identification
      return 'client_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 5);
    }

    function updateClientProfile(session) {
      // For demo purposes, we'll create/update profiles based on conversation patterns
      // In production, this would be linked to actual client identification
      
      let clientId = 'demo_client'; // Default demo client
      
      // Try to identify returning client based on conversation patterns
      const sessionKeywords = new Set();
      session.conversationData.transcript.forEach(entry => {
        entry.text.toLowerCase().split(/\s+/).forEach(word => {
          if (word.length > 3) sessionKeywords.add(word);
        });
      });
      
      // Check for existing similar profiles
      for (const [profileId, profile] of analyticsData.clientProfiles) {
        const commonKeywords = new Set();
        for (const [word] of profile.behaviorPatterns.commonKeywords) {
          if (sessionKeywords.has(word)) {
            commonKeywords.add(word);
          }
        }
        
        // If more than 30% keyword overlap, consider same client
        if (commonKeywords.size / Math.max(sessionKeywords.size, 1) > 0.3) {
          clientId = profileId;
          break;
        }
      }
      
      // Create new profile if no match found and this is a significant session
      if (clientId === 'demo_client' && session.duration > 60000 && sessionKeywords.size > 10) {
        clientId = generateClientId();
      }
      
      // Get or create client profile
      let clientProfile = analyticsData.clientProfiles.get(clientId);
      if (!clientProfile) {
        clientProfile = new ClientProfile(clientId);
        analyticsData.clientProfiles.set(clientId, clientProfile);
      }
      
      // Add session to profile
      clientProfile.addSession(session);
      
      console.log(`Updated profile for ${clientId}:`, clientProfile.getProfileSummary());
    }

    function getClientProfileInsights() {
      const insights = [];
      
      for (const [clientId, profile] of analyticsData.clientProfiles) {
        const summary = profile.getProfileSummary();
        
        insights.push({
          clientId,
          type: 'profile_insight',
          priority: profile.behaviorPatterns.conversionProbability > 0.7 ? 'high' : 
                   profile.behaviorPatterns.conversionProbability > 0.4 ? 'medium' : 'low',
          message: `Client ${clientId}: ${summary.conversionRate}% conversion rate, ${summary.totalSessions} sessions`,
          recommendations: summary.recommendations,
          lastInteraction: summary.lastInteraction
        });
      }
      
      return insights.sort((a, b) => {
        const priorityOrder = { high: 3, medium: 2, low: 1 };
        return priorityOrder[b.priority] - priorityOrder[a.priority];
      });
    }

    // Analytics Dashboard Functions
    function openAnalyticsDashboard() {
      updateDashboardDisplay();
      els.analyticsModal.style.display = 'flex';
      
      // Show outcome form if there's a completed session without outcome
      const lastSession = analyticsData.sessions[analyticsData.sessions.length - 1];
      if (lastSession && !lastSession.outcome.converted && !lastSession.outcome.notes) {
        els.outcomeForm.style.display = 'block';
      } else {
        els.outcomeForm.style.display = 'none';
      }
    }

    function closeAnalyticsDashboard() {
      els.analyticsModal.style.display = 'none';
    }

    function updateDashboardDisplay() {
      const summary = getAnalyticsSummary();
      
      // Update basic performance metrics
      els.totalSessions.textContent = summary.totalSessions;
      els.conversionRate.textContent = summary.conversionRate + '%';
      els.avgDuration.textContent = summary.avgSessionDuration + 'm';
      els.avgDealSize.textContent = '$' + summary.avgDealSize;
      
      // Update enhanced metrics
      const totalRevenueEl = document.getElementById('totalRevenue');
      const revenuePerHourEl = document.getElementById('revenuePerHour');
      const totalLeadsEl = document.getElementById('totalLeads');
      const qualifiedLeadsEl = document.getElementById('qualifiedLeads');
      const qualificationRateEl = document.getElementById('qualificationRate');
      const closedDealsEl = document.getElementById('closedDeals');
      const avgDealCycleEl = document.getElementById('avgDealCycle');
      const pipelineValueEl = document.getElementById('pipelineValue');
      const projectedRevenueEl = document.getElementById('projectedRevenue');
      const winProbabilityEl = document.getElementById('winProbability');
      
      if (totalRevenueEl) totalRevenueEl.textContent = '$' + summary.totalRevenue.toFixed(0);
      if (revenuePerHourEl) revenuePerHourEl.textContent = '$' + summary.revenuePerHour;
      if (totalLeadsEl) totalLeadsEl.textContent = summary.totalLeads;
      if (qualifiedLeadsEl) qualifiedLeadsEl.textContent = summary.qualifiedLeads;
      if (qualificationRateEl) qualificationRateEl.textContent = summary.qualificationRate + '%';
      if (closedDealsEl) closedDealsEl.textContent = summary.closedDeals;
      if (avgDealCycleEl) avgDealCycleEl.textContent = summary.avgDealCycle + ' zile';
      if (pipelineValueEl) pipelineValueEl.textContent = '$' + summary.pipelineValue;
      if (projectedRevenueEl) projectedRevenueEl.textContent = '$' + summary.projectedRevenue;
      if (winProbabilityEl) winProbabilityEl.textContent = summary.winProbability + '%';
      
      // Update performance insights
      updatePerformanceInsights(summary.performanceInsights);
      
      // Update session history
      updateSessionHistory();
      
      // Update top keywords (enhanced with performance data)
      updateTopKeywords(summary.topKeywords, summary.topPerformingKeywords);
      
      // Update client profiles
      updateClientProfilesDisplay();
    }

    function updateSessionHistory() {
      const container = els.sessionHistory;
      
      if (analyticsData.sessions.length === 0) {
        container.innerHTML = '<div class="muted" style="text-align:center;padding:20px">Nu există sesiuni încă</div>';
        return;
      }
      
      const sessionsHtml = analyticsData.sessions
        .slice(-10) // Show last 10 sessions
        .reverse()
        .map(session => {
          const summary = session.generateSummary();
          const outcome = session.outcome.converted ? '🟢 Convertit' : '🔴 Nu convertit';
          const dealSize = session.outcome.dealSize > 0 ? ` ($${session.outcome.dealSize})` : '';
          
          return `
            <div class="card" style="margin-bottom:12px;padding:12px">
              <div class="row" style="justify-content:space-between;margin-bottom:8px">
                <span style="font-weight:bold">${session.startTime.toLocaleDateString()} ${session.startTime.toLocaleTimeString()}</span>
                <span>${outcome}${dealSize}</span>
              </div>
              <div style="margin-bottom:8px">
                <span class="muted">Durata: ${summary.duration}m | </span>
                <span class="muted">Scor general: ${(summary.clientScore.overall * 100).toFixed(0)}%</span>
              </div>
              <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;font-size:12px">
                <div>Potential: ${(summary.clientScore.potential * 100).toFixed(0)}%</div>
                <div>Financiar: ${(summary.clientScore.financial * 100).toFixed(0)}%</div>
                <div>Premium: ${(summary.clientScore.premium * 100).toFixed(0)}%</div>
              </div>
              ${summary.keyInsights.length > 0 ? 
                '<div style="margin-top:8px;font-size:11px;color:var(--muted)">• ' + 
                summary.keyInsights.slice(0, 2).join('<br>• ') + '</div>' : ''}
            </div>
          `;
        })
        .join('');
      
      container.innerHTML = sessionsHtml;
    }

    function updatePerformanceInsights(insights) {
      const container = document.getElementById('performanceInsights');
      if (!container) return;
      
      if (insights.length === 0) {
        container.innerHTML = '<div class="muted" style="text-align:center;padding:12px">Nu există insights încă</div>';
        return;
      }
      
      const insightsHtml = insights.map(insight => {
        const bgColor = insight.type === 'success' ? 'var(--success)' :
                       insight.type === 'warning' ? 'var(--warning)' :
                       insight.type === 'insight' ? 'var(--text)' : 'var(--muted)';
        
        const textColor = insight.type === 'success' || insight.type === 'warning' ? '#fff' : 'var(--text)';
        
        return `
          <div style="background:${bgColor};color:${textColor};padding:12px;border-radius:8px;font-size:13px;line-height:1.4">
            ${insight.message}
          </div>
        `;
      }).join('');
      
      container.innerHTML = insightsHtml;
    }
    
    function updateTopKeywords(allKeywords, performingKeywords) {
      const container = els.topKeywords;
      if (!container) return;
      
      if (allKeywords.length === 0) {
        container.innerHTML = '<div class="muted">Nu există date încă</div>';
        return;
      }
      
      // Create enhanced keyword display with performance indicators
      const keywordsHtml = allKeywords.map(keyword => {
        const isPerforming = performingKeywords.some(pk => pk.word === keyword.word);
        const performanceCount = isPerforming ? performingKeywords.find(pk => pk.word === keyword.word).count : 0;
        const conversionRate = keyword.count > 0 ? ((performanceCount / keyword.count) * 100).toFixed(0) : 0;
        
        return `
          <div style="display:flex;justify-content:space-between;align-items:center;padding:6px 8px;margin:4px 0;background:#0f172a;border-radius:6px;font-size:12px">
            <span>${keyword.word}</span>
            <div style="display:flex;gap:8px;align-items:center">
              <span class="muted">${keyword.count}x</span>
              ${isPerforming ? `<span style="color:var(--success);font-size:10px">✓ ${conversionRate}%</span>` : ''}
            </div>
          </div>
        `;
      }).join('');
      
      container.innerHTML = `
        <div style="margin-bottom:8px;font-size:11px;color:var(--muted)">
          ✓ = Conversion rate pentru cuvantul cheie
        </div>
        ${keywordsHtml}
      `;
    }

    function updateClientProfilesDisplay() {
      const container = els.clientProfiles;
      
      if (analyticsData.clientProfiles.size === 0) {
        container.innerHTML = '<div class="muted">Nu există profiluri încă</div>';
        return;
      }
      
      const profiles = Array.from(analyticsData.clientProfiles.values())
        .map(profile => profile.getProfileSummary())
        .sort((a, b) => parseFloat(b.conversionRate) - parseFloat(a.conversionRate))
        .slice(0, 5); // Show top 5 profiles
      
      const profilesHtml = profiles
        .map(profile => {
          const conversionColor = parseFloat(profile.conversionRate) > 50 ? 'var(--success)' : 
                                 parseFloat(profile.conversionRate) > 25 ? 'var(--warning)' : 'var(--danger)';
          
          const lastInteraction = profile.lastInteraction ? 
            new Date(profile.lastInteraction).toLocaleDateString() : 'Necunoscut';
          
          return `
            <div style="padding:8px 0;border-bottom:1px solid #1f2b46">
              <div class="row" style="justify-content:space-between;margin-bottom:4px">
                <span style="font-weight:bold;font-size:12px">${profile.id.replace('client_', 'C')}</span>
                <span style="color:${conversionColor};font-weight:bold;font-size:12px">${profile.conversionRate}%</span>
              </div>
              <div style="font-size:11px;color:var(--muted);margin-bottom:4px">
                ${profile.totalSessions} sesiuni | Ultima: ${lastInteraction}
              </div>
              <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:4px;font-size:10px">
                <div>P: ${profile.avgScores.potential}%</div>
                <div>F: ${profile.avgScores.financial}%</div>
                <div>Pr: ${profile.avgScores.premium}%</div>
              </div>
              ${profile.recommendations.length > 0 ? 
                '<div style="font-size:10px;color:var(--warning);margin-top:4px">• ' + 
                profile.recommendations[0].substring(0, 50) + '...</div>' : ''}
            </div>
          `;
        })
        .join('');
      
      container.innerHTML = profilesHtml;
    }

    function saveSessionOutcome() {
      const lastSession = analyticsData.sessions[analyticsData.sessions.length - 1];
      if (!lastSession) return;
      
      const converted = lastSession.outcome.converted;
      const dealSize = parseFloat(els.dealSizeInput.value) || 0;
      const notes = els.sessionNotes.value.trim();
      
      lastSession.outcome.dealSize = dealSize;
      lastSession.outcome.notes = notes;
      
      // Update performance metrics
      if (converted && dealSize > 0) {
        const metrics = analyticsData.performanceMetrics;
        const totalDeals = (metrics.avgDealSize * (metrics.conversions - 1)) + dealSize;
        metrics.avgDealSize = totalDeals / metrics.conversions;
      }
      
      // Clear form and hide
      els.dealSizeInput.value = '';
      els.sessionNotes.value = '';
      els.outcomeForm.style.display = 'none';
      
      // Update dashboard
      updateDashboardDisplay();
      
      console.log('Session outcome saved:', lastSession.outcome);
    }

    // PDF Export Functions
    function exportFullPerformanceReport() {
      loadJsPDF().then(pdf => {
        jsPDF = pdf;
        const doc = new jsPDF();
        const summary = getAnalyticsSummary();
        const currentDate = new Date().toLocaleDateString('ro-RO');
        
        // Header
        doc.setFontSize(20);
        doc.setTextColor(40, 44, 52);
        doc.text('Sales Mood AI - Raport Complet Performance', 20, 25);
        
        doc.setFontSize(12);
        doc.setTextColor(100);
        doc.text(`Generat: ${currentDate}`, 20, 35);
        
        // Performance Overview
        doc.setFontSize(16);
        doc.setTextColor(40, 44, 52);
        doc.text('Prezentare Generala Performance', 20, 50);
        
        doc.setFontSize(11);
        doc.setTextColor(60);
        let yPos = 60;
        
        const metrics = [
          `Total Sesiuni: ${summary.totalSessions}`,
          `Rata de Conversie: ${summary.conversionRate}%`,
          `Durata Medie Sesiune: ${summary.avgSessionDuration} minute`,
          `Valoare Medie Deal: $${summary.avgDealSize}`,
          `Venituri Totale: $${summary.totalRevenue.toFixed(0)}`,
          `Venit pe Ora: $${summary.revenuePerHour}`,
          `Pipeline Value: $${summary.pipelineValue}`,
          `Venit Proiectat: $${summary.projectedRevenue}`
        ];
        
        metrics.forEach(metric => {
          doc.text(metric, 20, yPos);
          yPos += 8;
        });
        
        // Conversion Funnel
        yPos += 10;
        doc.setFontSize(14);
        doc.setTextColor(40, 44, 52);
        doc.text('Funel de Conversie', 20, yPos);
        yPos += 10;
        
        doc.setFontSize(11);
        doc.setTextColor(60);
        const funnelMetrics = [
          `Total Leaduri: ${summary.totalLeads}`,
          `Leaduri Calificate: ${summary.qualifiedLeads}`,
          `Rata Calificare: ${summary.qualificationRate}%`,
          `Dealuri Inchise: ${summary.closedDeals}`,
          `Ciclu Mediu Deal: ${summary.avgDealCycle} zile`
        ];
        
        funnelMetrics.forEach(metric => {
          doc.text(metric, 20, yPos);
          yPos += 8;
        });
        
        // Performance Insights
        if (summary.performanceInsights.length > 0) {
          yPos += 10;
          doc.setFontSize(14);
          doc.setTextColor(40, 44, 52);
          doc.text('Insights de Performance', 20, yPos);
          yPos += 10;
          
          doc.setFontSize(10);
          summary.performanceInsights.forEach(insight => {
            if (yPos > 250) {
              doc.addPage();
              yPos = 25;
            }
            
            const color = insight.type === 'success' ? [34, 197, 94] :
                         insight.type === 'warning' ? [245, 158, 11] : [100, 100, 100];
            doc.setTextColor(color[0], color[1], color[2]);
            
            const wrappedText = doc.splitTextToSize(insight.message, 170);
            doc.text(wrappedText, 20, yPos);
            yPos += wrappedText.length * 6 + 5;
          });
        }
        
        // Top Keywords
        if (summary.topPerformingKeywords.length > 0) {
          yPos += 10;
          if (yPos > 220) {
            doc.addPage();
            yPos = 25;
          }
          
          doc.setFontSize(14);
          doc.setTextColor(40, 44, 52);
          doc.text('Cuvinte Cheie Performante', 20, yPos);
          yPos += 10;
          
          doc.setFontSize(10);
          doc.setTextColor(60);
          summary.topPerformingKeywords.forEach(keyword => {
            doc.text(`${keyword.word}: ${keyword.count} conversii`, 20, yPos);
            yPos += 6;
          });
        }
        
        // Success Patterns
        if (summary.successPatterns.length > 0) {
          yPos += 10;
          if (yPos > 220) {
            doc.addPage();
            yPos = 25;
          }
          
          doc.setFontSize(14);
          doc.setTextColor(40, 44, 52);
          doc.text('Patterns de Succes', 20, yPos);
          yPos += 10;
          
          doc.setFontSize(10);
          doc.setTextColor(60);
          summary.successPatterns.forEach(pattern => {
            doc.text(`• ${pattern.replace('_', ' ').toUpperCase()}`, 20, yPos);
            yPos += 6;
          });
        }
        
        // Footer
        const pageCount = doc.internal.getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
          doc.setPage(i);
          doc.setFontSize(8);
          doc.setTextColor(150);
          doc.text('Sales Mood AI - Performance Report', 20, 285);
          doc.text(`Pagina ${i} din ${pageCount}`, 170, 285);
        }
        
        doc.save(`Sales_Performance_Report_${currentDate.replace(/\//g, '-')}.pdf`);
        console.log('Full performance report exported successfully');
        
      }).catch(error => {
        console.error('Error generating PDF:', error);
        alert('Eroare la încărcarea bibliotecii PDF. Încercați din nou.');
      });
    }
    
    function exportClientProfilesReport() {
      if (analyticsData.clientProfiles.size === 0) {
        alert('Nu exista profiluri de clienti pentru export.');
        return;
      }
      
      loadJsPDF().then(pdf => {
        jsPDF = pdf;
        const doc = new jsPDF();
        const currentDate = new Date().toLocaleDateString('ro-RO');
        
        // Header
        doc.setFontSize(20);
        doc.setTextColor(40, 44, 52);
        doc.text('Sales Mood AI - Raport Profiluri Clienti', 20, 25);
        
        doc.setFontSize(12);
        doc.setTextColor(100);
        doc.text(`Generat: ${currentDate}`, 20, 35);
        
        let yPos = 50;
        
        // Client Profiles
        const profiles = Array.from(analyticsData.clientProfiles.values())
          .map(profile => profile.getProfileSummary())
          .sort((a, b) => parseFloat(b.conversionRate) - parseFloat(a.conversionRate));
        
        profiles.forEach((profile, index) => {
          if (yPos > 240) {
            doc.addPage();
            yPos = 25;
          }
          
          // Client ID
          doc.setFontSize(14);
          doc.setTextColor(40, 44, 52);
          doc.text(`Client ${profile.id.replace('client_', '')}`, 20, yPos);
          yPos += 10;
          
          // Basic Stats
          doc.setFontSize(11);
          doc.setTextColor(60);
          const clientStats = [
            `Sesiuni: ${profile.totalSessions}`,
            `Rata Conversie: ${profile.conversionRate}%`,
            `Potential: ${profile.avgScores.potential}%`,
            `Financiar: ${profile.avgScores.financial}%`,
            `Premium: ${profile.avgScores.premium}%`
          ];
          
          clientStats.forEach(stat => {
            doc.text(stat, 20, yPos);
            yPos += 6;
          });
          
          // Recommendations
          if (profile.recommendations.length > 0) {
            yPos += 5;
            doc.setFontSize(10);
            doc.setTextColor(100);
            doc.text('Recomandari:', 20, yPos);
            yPos += 6;
            
            profile.recommendations.forEach(rec => {
              const wrappedRec = doc.splitTextToSize(`• ${rec}`, 170);
              doc.text(wrappedRec, 25, yPos);
              yPos += wrappedRec.length * 5;
            });
          }
          
          yPos += 10;
        });
        
        // Footer
        const pageCount = doc.internal.getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
          doc.setPage(i);
          doc.setFontSize(8);
          doc.setTextColor(150);
          doc.text('Sales Mood AI - Client Profiles Report', 20, 285);
          doc.text(`Pagina ${i} din ${pageCount}`, 170, 285);
        }
        
        doc.save(`Client_Profiles_Report_${currentDate.replace(/\//g, '-')}.pdf`);
        console.log('Client profiles report exported successfully');
        
      }).catch(error => {
        console.error('Error generating client PDF:', error);
        alert('Eroare la încărcarea bibliotecii PDF. Încercați din nou.');
      });
    }
    
    function exportCurrentSessionReport() {
      const lastSession = analyticsData.sessions[analyticsData.sessions.length - 1];
      if (!lastSession) {
        alert('Nu exista sesiuni pentru export.');
        return;
      }
      
      loadJsPDF().then(pdf => {
        jsPDF = pdf;
        const doc = new jsPDF();
        const summary = lastSession.generateSummary();
        const currentDate = new Date().toLocaleDateString('ro-RO');
        
        // Header
        doc.setFontSize(20);
        doc.setTextColor(40, 44, 52);
        doc.text('Sales Mood AI - Raport Sesiune', 20, 25);
        
        doc.setFontSize(12);
        doc.setTextColor(100);
        doc.text(`Generat: ${currentDate}`, 20, 35);
        doc.text(`Sesiune: ${lastSession.startTime.toLocaleDateString('ro-RO')} ${lastSession.startTime.toLocaleTimeString('ro-RO')}`, 20, 45);
        
        let yPos = 60;
        
        // Session Overview
        doc.setFontSize(16);
        doc.setTextColor(40, 44, 52);
        doc.text('Prezentare Generala Sesiune', 20, yPos);
        yPos += 15;
        
        doc.setFontSize(11);
        doc.setTextColor(60);
        const sessionStats = [
          `Durata: ${summary.duration} minute`,
          `Scor General Client: ${(summary.clientScore.overall * 100).toFixed(1)}%`,
          `Potential: ${(summary.clientScore.potential * 100).toFixed(1)}%`,
          `Financiar: ${(summary.clientScore.financial * 100).toFixed(1)}%`,
          `Premium: ${(summary.clientScore.premium * 100).toFixed(1)}%`,
          `Status: ${lastSession.outcome.converted ? 'CONVERTIT' : 'NU CONVERTIT'}`,
          `Valoare Deal: $${lastSession.outcome.dealSize}`
        ];
        
        sessionStats.forEach(stat => {
          doc.text(stat, 20, yPos);
          yPos += 8;
        });
        
        // Key Insights
        if (summary.keyInsights.length > 0) {
          yPos += 10;
          doc.setFontSize(14);
          doc.setTextColor(40, 44, 52);
          doc.text('Key Insights', 20, yPos);
          yPos += 10;
          
          doc.setFontSize(10);
          doc.setTextColor(60);
          summary.keyInsights.forEach(insight => {
            const wrappedInsight = doc.splitTextToSize(`• ${insight}`, 170);
            doc.text(wrappedInsight, 20, yPos);
            yPos += wrappedInsight.length * 6;
          });
        }
        
        // Session Notes
        if (lastSession.outcome.notes) {
          yPos += 10;
          doc.setFontSize(14);
          doc.setTextColor(40, 44, 52);
          doc.text('Note Sesiune', 20, yPos);
          yPos += 10;
          
          doc.setFontSize(10);
          doc.setTextColor(60);
          const wrappedNotes = doc.splitTextToSize(lastSession.outcome.notes, 170);
          doc.text(wrappedNotes, 20, yPos);
        }
        
        // Footer
        doc.setFontSize(8);
        doc.setTextColor(150);
        doc.text('Sales Mood AI - Session Report', 20, 285);
        doc.text('Pagina 1 din 1', 170, 285);
        
        doc.save(`Session_Report_${lastSession.startTime.toISOString().slice(0, 10)}.pdf`);
        console.log('Session report exported successfully');
        
      }).catch(error => {
        console.error('Error generating session PDF:', error);
        alert('Eroare la încărcarea bibliotecii PDF. Încercați din nou.');
      });
    }

    function toggleSpeech() {
      if (!recognition) {
        showError('Speech recognition nu este disponibil în acest browser');
        return;
      }
      
      if (isListening) {
        recognition.stop();
        isListening = false;
        els.toggleSpeech.textContent = '🎤 Activează recunoaștere';
        els.speechStatus.textContent = 'Oprit';
      } else {
        recognition.lang = currentLang === 'ro' ? 'ro-RO' : 'en-US';
        recognition.start();
        isListening = true;
        els.toggleSpeech.textContent = '🎤 Oprește recunoaștere';
        els.speechStatus.textContent = 'Ascultă...';
      }
    }

    function toggleLanguage() {
      currentLang = currentLang === 'ro' ? 'en' : 'ro';
      els.langToggle.textContent = currentLang === 'ro' ? '🌐 EN' : '🌐 RO';
      
      if (recognition && isListening) {
        recognition.stop();
        setTimeout(() => {
          recognition.lang = currentLang === 'ro' ? 'ro-RO' : 'en-US';
          recognition.start();
        }, 100);
      }
    }

    // Test function to manually trigger analysis with varied scenarios
    function testAnalysis() {
      const testScenarios = [
        {
          text: "Vreau să cumpăr cel mai bun pachet premium. Îmi permit orice preț pentru calitate profesională.",
          label: "CLIENT PREMIUM"
        },
        {
          text: "Nu sunt sigur dacă am nevoie de asta. Pare destul de scump pentru mine.",
          label: "CLIENT EZITANT"
        },
        {
          text: "Sună interesant. Spune-mi mai multe despre prețuri și ce include pachetul.",
          label: "CLIENT INTERESAT"
        },
        {
          text: "Am un buget limitat, dar sunt interesat. Ce opțiuni mai ieftine aveți?",
          label: "CLIENT BUGET LIMITAT"
        },
        {
          text: "Nu mă interesează deloc. Nu am timp pentru asta acum.",
          label: "CLIENT NEINTERESAT"
        },
        {
          text: "Am investit în soluții similare înainte. Vreau ceva profesional și de calitate.",
          label: "CLIENT EXPERIMENTAT"
        }
      ];
      
      // Select random scenario
      const scenario = testScenarios[Math.floor(Math.random() * testScenarios.length)];
      
      console.log('Testing analysis with scenario:', scenario.label, '-', scenario.text);
      analyzeKeywords(scenario.text);
      
      // Also add to transcript for visibility
      els.transcript.innerHTML = '<div style="color:var(--success);margin-bottom:4px;font-weight:bold">[TEST - ' + scenario.label + '] ' + scenario.text + '</div>' + els.transcript.innerHTML;
    }

    // Event listeners
    els.agreeBtn.addEventListener('click', async () => {
      els.consent.style.display = 'none';
      try {
        await initMedia();
        await initModels();
      } catch (err) {
        showError('Eroare inițializare: ' + err.message);
        console.error(err);
      }
    });

    els.declineBtn.addEventListener('click', () => {
      alert('Ai ales să nu pornești demo-ul. Poți închide pagina.');
    });

    els.startBtn.addEventListener('click', start);
    els.stopBtn.addEventListener('click', stop);
    els.pauseBtn.addEventListener('click', pause);
    els.toggleSpeech.addEventListener('click', toggleSpeech);
    els.langToggle.addEventListener('click', toggleLanguage);
    els.testAnalysis.addEventListener('click', testAnalysis);
    els.generateScript.addEventListener('click', () => {
      const script = generatePersonalizedScript();
      if (script) {
        showScriptSuggestion(script);
      } else {
        alert('Nu s-a putut genera un script. Incercați să analizați mai întâi o conversație.');
      }
    });
    
    // Analytics dashboard event listeners
    els.toggleAnalytics.addEventListener('click', openAnalyticsDashboard);
    els.closeAnalytics.addEventListener('click', closeAnalyticsDashboard);
    
    // Session outcome event listeners
    els.convertedYes.addEventListener('click', () => {
      const lastSession = analyticsData.sessions[analyticsData.sessions.length - 1];
      if (lastSession) {
        lastSession.outcome.converted = true;
        analyticsData.performanceMetrics.conversions++;
        els.convertedYes.style.background = 'var(--success)';
        els.convertedNo.style.background = '#1c2a49';
      }
    });
    
    els.convertedNo.addEventListener('click', () => {
      const lastSession = analyticsData.sessions[analyticsData.sessions.length - 1];
      if (lastSession) {
        lastSession.outcome.converted = false;
        els.convertedNo.style.background = 'var(--danger)';
        els.convertedYes.style.background = '#1c2a49';
      }
    });
    
    els.saveOutcome.addEventListener('click', saveSessionOutcome);
    
    // PDF Export event listeners
    if (els.exportFullReport) {
      els.exportFullReport.addEventListener('click', exportFullPerformanceReport);
    }
    
    if (els.exportClientReport) {
      els.exportClientReport.addEventListener('click', exportClientProfilesReport);
    }
    
    if (els.exportSessionReport) {
      els.exportSessionReport.addEventListener('click', exportCurrentSessionReport);
    }

    // ===========================================
    // 🚀 SALES MOOD AI V2 - ADVANCED AI FEATURES
    // ===========================================
    
    // Enhanced Speech Recognition with Advanced Sentiment Analysis
    class AdvancedSpeechAnalyzer {
      constructor() {
        this.recognition = null;
        this.isListening = false;
        this.conversationHistory = [];
        this.sentimentEngine = new SentimentAnalysisEngine();
        this.conversationFlow = new ConversationFlowAnalyzer();
        this.init();
      }
      
      init() {
        if ('webkitSpeechRecognition' in window) {
          this.recognition = new webkitSpeechRecognition();
        } else if ('SpeechRecognition' in window) {
          this.recognition = new SpeechRecognition();
        }
        
        if (this.recognition) {
          this.setupRecognition();
        }
      }
      
      setupRecognition() {
        this.recognition.continuous = true;
        this.recognition.interimResults = true;
        this.recognition.lang = currentLang === 'ro' ? 'ro-RO' : 'en-US';
        
        this.recognition.onresult = (event) => {
          let finalTranscript = '';
          let interimTranscript = '';
          
          for (let i = event.resultIndex; i < event.results.length; i++) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
              finalTranscript += transcript;
            } else {
              interimTranscript += transcript;
            }
          }
          
          if (finalTranscript) {
            this.processTranscript(finalTranscript);
            this.conversationHistory.push({
              timestamp: Date.now(),
              text: finalTranscript,
              sentiment: this.sentimentEngine.analyze(finalTranscript),
              speaker: 'client'
            });
          }
          
          // Update transcript display
          const transcriptEl = document.getElementById('transcript');
          if (transcriptEl) {
            transcriptEl.innerHTML = finalTranscript + '<span style="opacity:0.5">' + interimTranscript + '</span>';
          }
        };
        
        this.recognition.onerror = (event) => {
          console.warn('Speech recognition error:', event.error);
        };
      }
      
      processTranscript(text) {
        // Real-time sentiment analysis
        const sentiment = this.sentimentEngine.analyze(text);
        
        // Update conversation flow metrics
        this.conversationFlow.update(text, sentiment);
        
        // Detect objections and generate responses
        const objection = this.detectObjection(text);
        if (objection) {
          this.showObjectionResponse(objection);
        }
        
        // Update client potential scores
        this.updateClientScores(text, sentiment);
        
        // Check timing recommendations
        this.checkTimingRecommendations();
      }
      
      detectObjection(text) {
        const lowerText = text.toLowerCase();
        
        for (const [type, data] of Object.entries(objectionDatabase)) {
          const keywords = data.keywords[currentLang] || data.keywords.ro;
          
          for (const keyword of keywords) {
            if (lowerText.includes(keyword.toLowerCase())) {
              return {
                type,
                keyword,
                confidence: this.calculateObjectionConfidence(text, keyword)
              };
            }
          }
        }
        
        return null;
      }
      
      calculateObjectionConfidence(text, keyword) {
        const words = text.toLowerCase().split(' ');
        const keywordIndex = words.findIndex(word => word.includes(keyword.toLowerCase()));
        
        // Higher confidence for exact matches and context
        let confidence = 0.6;
        
        if (words.includes(keyword.toLowerCase())) confidence += 0.2;
        if (keywordIndex === 0) confidence += 0.1; // First word = stronger signal
        if (text.includes('nu')) confidence += 0.1; // Negative context in Romanian
        
        return Math.min(confidence, 1.0);
      }
      
      showObjectionResponse(objection) {
        const responses = objectionDatabase[objection.type].responses[currentLang] || 
                         objectionDatabase[objection.type].responses.ro;
        
        const randomResponse = responses[Math.floor(Math.random() * responses.length)];
        
        // Show live recommendation
        const recommendationEl = document.getElementById('liveRecommendations');
        const textEl = document.getElementById('recommendationText');
        
        if (recommendationEl && textEl) {
          textEl.innerHTML = `
            <div style="margin-bottom:8px"><strong>🚨 Obiecție detectată: ${objection.type.toUpperCase()}</strong></div>
            <div style="background:#0f172a;padding:8px;border-radius:6px;margin-bottom:8px">
              <strong>Răspuns sugerat:</strong><br>
              ${randomResponse}
            </div>
            <div class="muted" style="font-size:11px">Încredere: ${(objection.confidence * 100).toFixed(0)}%</div>
          `;
          recommendationEl.style.display = 'block';
          
          // Auto-hide after 15 seconds
          setTimeout(() => {
            recommendationEl.style.display = 'none';
          }, 15000);
        }
        
        // Track objection
        detectedObjections[objection.type].count++;
        detectedObjections[objection.type].lastDetected = Date.now();
        detectedObjections[objection.type].responses.push(randomResponse);
      }
      
      updateClientScores(text, sentiment) {
        // Enhanced keyword analysis for V2
        this.analyzeClientPotential(text);
        this.analyzeFinancialPower(text);
        this.analyzePremiumOpenness(text);
        
        // Update display
        this.updateScoreDisplays();
      }
      
      analyzeClientPotential(text) {
        const lowerText = text.toLowerCase();
        let score = analysisData.clientPotential.score;
        
        const positiveKeywords = keywordAnalysis.clientPotential.positive[currentLang] || 
                                keywordAnalysis.clientPotential.positive.ro;
        const negativeKeywords = keywordAnalysis.clientPotential.negative[currentLang] || 
                                keywordAnalysis.clientPotential.negative.ro;
        
        positiveKeywords.forEach(keyword => {
          if (lowerText.includes(keyword)) {
            score = Math.min(score + 0.15, 1.0);
            analysisData.clientPotential.keywords.push(keyword);
          }
        });
        
        negativeKeywords.forEach(keyword => {
          if (lowerText.includes(keyword)) {
            score = Math.max(score - 0.1, 0);
          }
        });
        
        analysisData.clientPotential.score = score;
      }
      
      analyzeFinancialPower(text) {
        const lowerText = text.toLowerCase();
        let score = analysisData.financialPower.score;
        
        const positiveKeywords = keywordAnalysis.financialPower.positive[currentLang] || 
                                keywordAnalysis.financialPower.positive.ro;
        const negativeKeywords = keywordAnalysis.financialPower.negative[currentLang] || 
                                keywordAnalysis.financialPower.negative.ro;
        
        positiveKeywords.forEach(keyword => {
          if (lowerText.includes(keyword)) {
            score = Math.min(score + 0.2, 1.0);
            analysisData.financialPower.keywords.push(keyword);
          }
        });
        
        negativeKeywords.forEach(keyword => {
          if (lowerText.includes(keyword)) {
            score = Math.max(score - 0.15, 0);
          }
        });
        
        analysisData.financialPower.score = score;
      }
      
      analyzePremiumOpenness(text) {
        const lowerText = text.toLowerCase();
        let score = analysisData.premiumOpenness.score;
        
        const positiveKeywords = keywordAnalysis.premium.positive[currentLang] || 
                                keywordAnalysis.premium.positive.ro;
        const negativeKeywords = keywordAnalysis.premium.negative[currentLang] || 
                                keywordAnalysis.premium.negative.ro;
        
        positiveKeywords.forEach(keyword => {
          if (lowerText.includes(keyword)) {
            score = Math.min(score + 0.18, 1.0);
            analysisData.premiumOpenness.keywords.push(keyword);
          }
        });
        
        negativeKeywords.forEach(keyword => {
          if (lowerText.includes(keyword)) {
            score = Math.max(score - 0.12, 0);
          }
        });
        
        analysisData.premiumOpenness.score = score;
      }
      
      updateScoreDisplays() {
        // Update client potential
        const potentialEl = document.getElementById('clientPotential');
        if (potentialEl) {
          const score = analysisData.clientPotential.score;
          const level = score > 0.7 ? 'Înalt' : score > 0.4 ? 'Mediu' : 'Scăzut';
          const color = score > 0.7 ? 'var(--success)' : score > 0.4 ? 'var(--warning)' : 'var(--danger)';
          potentialEl.innerHTML = `<span style="color:${color}">${level} (${(score*100).toFixed(0)}%)</span>`;
        }
        
        // Update financial power
        const financialEl = document.getElementById('financialPower');
        if (financialEl) {
          const score = analysisData.financialPower.score;
          const level = score > 0.7 ? 'Mare' : score > 0.4 ? 'Medie' : 'Limitată';
          const color = score > 0.7 ? 'var(--success)' : score > 0.4 ? 'var(--warning)' : 'var(--danger)';
          financialEl.innerHTML = `<span style="color:${color}">${level} (${(score*100).toFixed(0)}%)</span>`;
        }
        
        // Update premium openness
        const premiumEl = document.getElementById('premiumOpenness');
        if (premiumEl) {
          const score = analysisData.premiumOpenness.score;
          const level = score > 0.7 ? 'Foarte deschis' : score > 0.4 ? 'Moderat' : 'Conservator';
          const color = score > 0.7 ? 'var(--success)' : score > 0.4 ? 'var(--warning)' : 'var(--danger)';
          premiumEl.innerHTML = `<span style="color:${color}">${level} (${(score*100).toFixed(0)}%)</span>`;
        }
      }
      
      checkTimingRecommendations() {
        const now = Date.now();
        
        // Calculate timing scores
        timingState.trustLevel = (analysisData.clientPotential.score + analysisData.financialPower.score) / 2;
        timingState.engagementMomentum = this.calculateEngagementMomentum();
        
        // Check if it's time to mention pricing
        if (this.shouldMentionPricing()) {
          this.showTimingRecommendation('pricing', 'Momentul potrivit să menționezi prețurile și opțiunile.');
        }
        
        // Check if it's time to close
        if (this.shouldAttemptClose()) {
          this.showTimingRecommendation('closing', 'Semnale puternice de cumpărare detectate. Încearcă să închizi!');
        }
      }
      
      shouldMentionPricing() {
        return timingState.trustLevel >= timingThresholds.pricing.minTrust &&
               timingState.engagementMomentum >= timingThresholds.pricing.minEngagement &&
               this.conversationHistory.length >= timingThresholds.pricing.minConversationLength;
      }
      
      shouldAttemptClose() {
        return timingState.trustLevel >= timingThresholds.closing.minTrust &&
               timingState.engagementMomentum >= timingThresholds.closing.minEngagement &&
               this.conversationHistory.length >= timingThresholds.closing.minConversationLength;
      }
      
      calculateEngagementMomentum() {
        if (this.conversationHistory.length < 2) return 0;
        
        const recentMessages = this.conversationHistory.slice(-3);
        let momentum = 0;
        
        recentMessages.forEach(msg => {
          if (msg.sentiment && msg.sentiment.overall > 0.5) momentum += 0.3;
          if (msg.text.length > 20) momentum += 0.2; // Longer responses = more engagement
        });
        
        return Math.min(momentum, 1.0);
      }
      
      showTimingRecommendation(type, message) {
        if (timingState.lastRecommendation && 
            Date.now() - timingState.lastRecommendation < 30000) return; // Avoid spam
        
        const recommendationEl = document.getElementById('liveRecommendations');
        const textEl = document.getElementById('recommendationText');
        
        if (recommendationEl && textEl) {
          textEl.innerHTML = `
            <div style="margin-bottom:8px"><strong>⏰ Timing Optimal</strong></div>
            <div style="color:var(--success);font-weight:bold;margin-bottom:4px">${message}</div>
            <div class="muted" style="font-size:11px">
              Încredere: ${(timingState.trustLevel*100).toFixed(0)}% | 
              Angajament: ${(timingState.engagementMomentum*100).toFixed(0)}%
            </div>
          `;
          recommendationEl.style.display = 'block';
          
          timingState.lastRecommendation = Date.now();
          timingState.timingHistory.push({ type, timestamp: Date.now(), message });
          
          // Auto-hide after 10 seconds
          setTimeout(() => {
            recommendationEl.style.display = 'none';
          }, 10000);
        }
      }
      
      start() {
        if (this.recognition && !this.isListening) {
          try {
            this.recognition.start();
            this.isListening = true;
            document.getElementById('speechStatus').textContent = 'Ascult...';
            document.getElementById('toggleSpeech').textContent = '🛑 Oprește recunoaștere';
          } catch (error) {
            console.error('Error starting speech recognition:', error);
          }
        }
      }
      
      stop() {
        if (this.recognition && this.isListening) {
          this.recognition.stop();
          this.isListening = false;
          document.getElementById('speechStatus').textContent = 'Oprit';
          document.getElementById('toggleSpeech').textContent = '🎤 Activează recunoaștere';
        }
      }
      
      toggle() {
        if (this.isListening) {
          this.stop();
        } else {
          this.start();
        }
      }
    }
    
    // Sentiment Analysis Engine
    class SentimentAnalysisEngine {
      constructor() {
        this.emotionKeywords = {
          positive: {
            ro: ['excelent', 'fantastic', 'perfect', 'minunat', 'grozav', 'bun', 'da', 'sigur', 'mulțumesc', 'apreciez'],
            en: ['excellent', 'fantastic', 'perfect', 'wonderful', 'great', 'good', 'yes', 'sure', 'thanks', 'appreciate']
          },
          negative: {
            ro: ['rău', 'prost', 'nu', 'nu-mi place', 'îngrijorat', 'problemă', 'dificil', 'complicat', 'scump'],
            en: ['bad', 'poor', 'no', 'dont like', 'worried', 'problem', 'difficult', 'complicated', 'expensive']
          },
          uncertainty: {
            ro: ['nu știu', 'poate', 'nu sunt sigur', 'să mă gândesc', 'vedem', 'depinde'],
            en: ['dont know', 'maybe', 'not sure', 'think about it', 'see', 'depends']
          }
        };
      }
      
      analyze(text) {
        const lowerText = text.toLowerCase();
        
        let sentiment = {
          positive: 0,
          negative: 0,
          uncertainty: 0,
          overall: 0.5,
          confidence: 0,
          emotions: []
        };
        
        // Count keyword matches
        const lang = currentLang === 'ro' ? 'ro' : 'en';
        
        this.emotionKeywords.positive[lang].forEach(keyword => {
          if (lowerText.includes(keyword)) {
            sentiment.positive += 0.1;
            sentiment.emotions.push({ type: 'positive', keyword, weight: 0.1 });
          }
        });
        
        this.emotionKeywords.negative[lang].forEach(keyword => {
          if (lowerText.includes(keyword)) {
            sentiment.negative += 0.1;
            sentiment.emotions.push({ type: 'negative', keyword, weight: 0.1 });
          }
        });
        
        this.emotionKeywords.uncertainty[lang].forEach(keyword => {
          if (lowerText.includes(keyword)) {
            sentiment.uncertainty += 0.1;
            sentiment.emotions.push({ type: 'uncertainty', keyword, weight: 0.1 });
          }
        });
        
        // Calculate overall sentiment
        sentiment.overall = Math.max(0, Math.min(1, 0.5 + sentiment.positive - sentiment.negative));
        sentiment.confidence = Math.min(1, (sentiment.positive + sentiment.negative + sentiment.uncertainty));
        
        return sentiment;
      }
    }
    
    // Conversation Flow Analyzer
    class ConversationFlowAnalyzer {
      constructor() {
        this.turnHistory = [];
        this.speakingPatterns = {
          averageResponseTime: 0,
          wordCount: 0,
          turnTaking: 0
        };
      }
      
      update(text, sentiment) {
        const now = Date.now();
        const wordCount = text.split(' ').length;
        
        this.turnHistory.push({
          timestamp: now,
          text: text,
          wordCount: wordCount,
          sentiment: sentiment,
          speaker: 'client'
        });
        
        this.updateMetrics();
      }
      
      updateMetrics() {
        if (this.turnHistory.length < 2) return;
        
        // Calculate average response time
        const responseTimes = [];
        for (let i = 1; i < this.turnHistory.length; i++) {
          responseTimes.push(this.turnHistory[i].timestamp - this.turnHistory[i-1].timestamp);
        }
        
        this.speakingPatterns.averageResponseTime = 
          responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
        
        // Calculate average word count
        this.speakingPatterns.wordCount = 
          this.turnHistory.reduce((sum, turn) => sum + turn.wordCount, 0) / this.turnHistory.length;
        
        // Analyze turn-taking patterns
        this.speakingPatterns.turnTaking = this.analyzeTurnTaking();
      }
      
      analyzeTurnTaking() {
        // Measure conversation flow quality
        let flowScore = 0.5;
        
        // Good indicators: consistent response times, adequate word counts
        if (this.speakingPatterns.averageResponseTime > 1000 && 
            this.speakingPatterns.averageResponseTime < 10000) {
          flowScore += 0.2; // Good thinking time
        }
        
        if (this.speakingPatterns.wordCount > 5) {
          flowScore += 0.2; // Detailed responses
        }
        
        return Math.min(1.0, flowScore);
      }
    }
    
    // Predictive Analytics Engine
    class PredictiveAnalytics {
      constructor() {
        this.closingProbability = 0;
        this.dealRisk = 0;
        this.nextBestActions = [];
      }
      
      calculateClosingProbability() {
        const factors = {
          clientPotential: analysisData.clientPotential.score * 0.3,
          financialPower: analysisData.financialPower.score * 0.25,
          premiumOpenness: analysisData.premiumOpenness.score * 0.15,
          trustLevel: timingState.trustLevel * 0.20,
          engagement: timingState.engagementMomentum * 0.10
        };
        
        this.closingProbability = Object.values(factors).reduce((sum, val) => sum + val, 0);
        return this.closingProbability;
      }
      
      assessDealRisk() {
        let riskScore = 0;
        
        // High risk indicators
        if (analysisData.clientPotential.score < 0.3) riskScore += 0.3;
        if (analysisData.financialPower.score < 0.2) riskScore += 0.4;
        if (timingState.engagementMomentum < 0.3) riskScore += 0.3;
        
        this.dealRisk = riskScore;
        return this.dealRisk;
      }
      
      generateNextBestActions() {
        this.nextBestActions = [];
        
        const closingProb = this.calculateClosingProbability();
        const riskLevel = this.assessDealRisk();
        
        if (closingProb > 0.7) {
          this.nextBestActions.push({
            action: 'attempt_close',
            priority: 'high',
            message: 'Probabilitate înaltă de închidere. Încearcă să finalizezi!',
            confidence: closingProb
          });
        } else if (closingProb > 0.4) {
          this.nextBestActions.push({
            action: 'present_options',
            priority: 'medium',
            message: 'Prezintă opțiuni și beneficii specifice.',
            confidence: closingProb
          });
        } else {
          this.nextBestActions.push({
            action: 'build_value',
            priority: 'medium',
            message: 'Construiește valoarea și adresează obiecțiile.',
            confidence: 1 - closingProb
          });
        }
        
        if (riskLevel > 0.6) {
          this.nextBestActions.push({
            action: 'risk_mitigation',
            priority: 'high',
            message: 'Risc ridicat - focalizează pe încredere și siguranță.',
            confidence: riskLevel
          });
        }
        
        return this.nextBestActions;
      }
    }
    
    // Initialize V2 Advanced AI Systems
    let advancedSpeechAnalyzer;
    let predictiveAnalytics;
    
    // Initialize advanced systems after main initialization
    function initializeV2Systems() {
      advancedSpeechAnalyzer = new AdvancedSpeechAnalyzer();
      predictiveAnalytics = new PredictiveAnalytics();
      
      console.log('🚀 Sales Mood AI V2 Advanced Systems Initialized');
      
      // Setup enhanced event listeners
      setupV2EventListeners();
    }
    
    function setupV2EventListeners() {
      // Enhanced speech toggle
      const toggleSpeechBtn = document.getElementById('toggleSpeech');
      if (toggleSpeechBtn) {
        toggleSpeechBtn.addEventListener('click', () => {
          if (advancedSpeechAnalyzer) {
            advancedSpeechAnalyzer.toggle();
          }
        });
      }
      
      // Test advanced analysis
      const testAnalysisBtn = document.getElementById('testAnalysis');
      if (testAnalysisBtn) {
        testAnalysisBtn.addEventListener('click', () => {
          // Simulate conversation for testing
          const testPhrases = {
            ro: ['Sunt foarte interesat de această soluție', 'Care este prețul?', 'Nu sunt sigur că îmi permit'],
            en: ['I am very interested in this solution', 'What is the price?', 'I am not sure I can afford it']
          };
          
          const phrases = testPhrases[currentLang] || testPhrases.ro;
          const randomPhrase = phrases[Math.floor(Math.random() * phrases.length)];
          
          if (advancedSpeechAnalyzer) {
            advancedSpeechAnalyzer.processTranscript(randomPhrase);
          }
        });
      }
      
      // Update predictive analytics every 5 seconds
      setInterval(() => {
        if (predictiveAnalytics && isAnalyzing && running) {
          const closingProb = predictiveAnalytics.calculateClosingProbability();
          const dealRisk = predictiveAnalytics.assessDealRisk();
          const actions = predictiveAnalytics.generateNextBestActions();
          
          // Update probability display if element exists
          const probEl = document.getElementById('winProbability');
          if (probEl) {
            probEl.textContent = `${(closingProb * 100).toFixed(0)}%`;
          }
        }
      }, 5000);
    }
    
    // Initialize
    setStatus('uninitialized');
    
    // Initialize V2 Advanced AI Systems after consent
    document.getElementById('agreeBtn').addEventListener('click', () => {
      setTimeout(() => {
        initializeV2Systems();
      }, 2000); // Initialize after UI setup
    });
  </script>
</body>
</html>